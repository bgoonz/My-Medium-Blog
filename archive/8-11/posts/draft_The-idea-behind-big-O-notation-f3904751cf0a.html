<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>The idea behind big O notation</title>
    <style>
        * {
            font-family: Georgia, Cambria, "Times New Roman", Times, serif;
        }

        html,
        body {
            margin: 0;
            padding: 0;
        }

        h1 {
            font-size: 50px;
            margin-bottom: 17px;
            color: #333;
        }

        h2 {
            font-size: 24px;
            line-height: 1.6;
            margin: 30px 0 0 0;
            margin-bottom: 18px;
            margin-top: 33px;
            color: #333;
        }

        h3 {
            font-size: 30px;
            margin: 10px 0 20px 0;
            color: #333;
        }

        header {
            width: 640px;
            margin: auto;
        }

        section {
            width: 640px;
            margin: auto;
        }

        section p {
            margin-bottom: 27px;
            font-size: 20px;
            line-height: 1.6;
            color: #333;
        }

        section img {
            max-width: 640px;
        }

        footer {
            padding: 0 20px;
            margin: 50px 0;
            text-align: center;
            font-size: 12px;
        }

        .aspectRatioPlaceholder {
            max-width: auto !important;
            max-height: auto !important;
        }

        .aspectRatioPlaceholder-fill {
            padding-bottom: 0 !important;
        }

        header,
        section[data-field="subtitle"],
        section[data-field="description"] {
            display: none;
        }
    </style>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bgoonz/GIT-CDN-FILES/mdn-article.css">
</head>

<body>
    <article class="h-entry">
        <header>
            <h1 class="p-name">The idea behind big O notation</h1>
        </header>
        <section data-field="subtitle" class="p-summary">
            Big O notation is the language we use for talking about how long an
            algorithm takes to run. It’s how we compare the efficiency of different…
        </section>
        <section data-field="body" class="e-content">
            <section name="0b99" class="section section--body section--first">
                <div class="section-divider">
                    <hr class="section-divider" />
                </div>
                <div class="section-content">
                    <div class="section-inner sectionLayout--insetColumn">
                        <p name="10cc" id="10cc" class="graf graf--p graf--empty graf--leading">
                            <br />
                        </p>
                        <p name="b816" id="b816" class="graf graf--p graf--empty graf-after--p">
                            <br />
                        </p>
                        <h3 name="9822" id="9822" class="graf graf--h3 graf-after--p graf--title">
                            The idea behind big O notation
                        </h3>
                        <p name="4efd" id="4efd" class="graf graf--p graf-after--h3">
                            <strong class="markup--strong markup--p-strong">Big O notation is the language we use for talking about how
                                long an<br />algorithm takes to run</strong>. It’s how we compare the efficiency of<br />different
                            approaches to a problem.
                        </p>
                        <p name="aba1" id="aba1" class="graf graf--p graf-after--p">
                            With big O notation we express the runtime in terms of
                        </p>
                        <h3 name="6b94" id="6b94" class="graf graf--h3 graf-after--p">
                            how quickly it grows relative to the input, as the input gets
                            arbitrarily large_.
                        </h3>
                        <ol class="postList">
                            <li name="fc73" id="fc73" class="graf graf--li graf-after--h3">
                                <strong class="markup--strong markup--li-strong">how quickly the runtime grows</strong> — 
                            </li>
                        </ol>
                        <p name="28d8" id="28d8" class="graf graf--p graf-after--li">
                            It’s hard to pin down the
                            <em class="markup--em markup--p-em">exact runtime</em> of an
                            algorithm.
                        </p>
                        <ul class="postList">
                            <li name="0d3d" id="0d3d" class="graf graf--li graf-after--p">
                                It depends on the speed of the processor,
                            </li>
                            <li name="105b" id="105b" class="graf graf--li graf-after--li">
                                what else the computer is running, etc.
                            </li>
                        </ul>
                        <p name="0158" id="0158" class="graf graf--p graf-after--li">
                            So instead of talking about the runtime directly, we use big O
                            notation to talk about
                            <em class="markup--em markup--p-em">how quickly the runtime grows</em>.
                        </p>
                        <ol class="postList">
                            <li name="bcc8" id="bcc8" class="graf graf--li graf-after--p">
                                <strong class="markup--strong markup--li-strong">relative to the input</strong> — If we were measuring our runtime directly,
                            </li>
                        </ol>
                        <p name="2d37" id="2d37" class="graf graf--p graf-after--li">
                            we could express our speed in seconds. Since we’re measuring
                            <em class="markup--em markup--p-em">how quickly our runtime grows</em>, we need to express our speed in terms of…something else. With
                            Big O notation, we use the size of the input, which we call “n.”
                            So we can say things like the runtime grows “on the order of the
                            size of the input” () or “on the order of the square of the size
                            of the input” ().
                        </p>
                        <ol class="postList">
                            <li name="e264" id="e264" class="graf graf--li graf-after--p">
                                <strong class="markup--strong markup--li-strong">as the input gets arbitrarily large</strong> — 
                            </li>
                        </ol>
                        <p name="ef71" id="ef71" class="graf graf--p graf-after--li">
                            Our algorithm may have steps that seem expensive when n is small
                            but are eclipsed eventually by other steps as n gets huge. For
                            big O analysis, we care most about the stuff that grows fastest
                            as the input grows, because everything else is quickly eclipsed
                            as n gets very large. (If you know what an asymptote is, you
                            might see why “big O analysis” is sometimes called “asymptotic
                            analysis.”)hy “big O analysis” is sometimes called
                        </p>
                        <pre name="1dc9" id="1dc9" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">&quot;asymptotic analysis.&quot;)</code></pre>
                        <pre name="a69a" id="a69a" class="
                  graf graf--pre graf--empty
                  graf-after--pre
                  graf--trailing
                "><br></pre>
                    </div>
                </div>
            </section>
            <section name="9c1f" class="section section--body">
                <div class="section-divider">
                    <hr class="section-divider" />
                </div>
                <div class="section-content">
                    <div class="section-inner sectionLayout--insetColumn">
                        <h3 name="ff4a" id="ff4a" class="graf graf--h3 graf--leading graf--trailing">
                            Data Structures Reference
                        </h3>
                    </div>
                </div>
            </section>
            <section name="dc50" class="section section--body">
                <div class="section-divider">
                    <hr class="section-divider" />
                </div>
                <div class="section-content">
                    <div class="section-inner sectionLayout--insetColumn">
                        <h3 name="616b" id="616b" class="graf graf--h3 graf--leading">
                            Array
                        </h3>
                        <p name="12f7" id="12f7" class="graf graf--p graf-after--h3">
                            Stores things in order. Has quick lookups by index.
                        </p>
                        <figure name="81aa" id="81aa" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-image-id="1*b31hiO4ynbDLRrXWEFF4aQ.png" src="https://cdn-images-1.medium.com/max/800/1*b31hiO4ynbDLRrXWEFF4aQ.png" />
                        </figure>
                        <figure name="6d22" id="6d22" class="graf graf--figure graf-after--figure">
                            <img class="graf-image" data-image-id="1*b31hiO4ynbDLRrXWEFF4aQ.png" src="https://cdn-images-1.medium.com/max/800/1*b31hiO4ynbDLRrXWEFF4aQ.png" />
                        </figure>
                        <h3 name="c90a" id="c90a" class="graf graf--h3 graf-after--figure">
                            Linked List
                        </h3>
                        <figure name="21ea" id="21ea" class="graf graf--figure graf-after--h3">
                            <img class="graf-image" data-image-id="1*b31hiO4ynbDLRrXWEFF4aQ.png" src="https://cdn-images-1.medium.com/max/800/1*b31hiO4ynbDLRrXWEFF4aQ.png" />
                        </figure>
                        <p name="c9ce" id="c9ce" class="graf graf--p graf-after--figure">
                            Also stores things in order. Faster insertions and deletions
                            than<br />arrays, but slower lookups (you have to “walk down”
                            the whole list).
                        </p>
                        <p name="6ab2" id="6ab2" class="graf graf--p graf-after--p">!</p>
                        <h3 name="3158" id="3158" class="graf graf--h3 graf-after--p">
                            Queue
                        </h3>
                        <p name="0707" id="0707" class="graf graf--p graf-after--h3">
                            Like the line outside a busy restaurant. “First come, first
                            served.”
                        </p>
                        <figure name="da5d" id="da5d" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-image-id="1*b31hiO4ynbDLRrXWEFF4aQ.png" src="https://cdn-images-1.medium.com/max/800/1*b31hiO4ynbDLRrXWEFF4aQ.png" />
                        </figure>
                        <h3 name="44d7" id="44d7" class="graf graf--h3 graf-after--figure">
                            Stack
                        </h3>
                        <figure name="62aa" id="62aa" class="graf graf--figure graf-after--h3">
                            <img class="graf-image" data-image-id="1*b31hiO4ynbDLRrXWEFF4aQ.png" src="https://cdn-images-1.medium.com/max/800/1*b31hiO4ynbDLRrXWEFF4aQ.png" />
                        </figure>
                        <figure name="bada" id="bada" class="graf graf--figure graf-after--figure">
                            <img class="graf-image" data-image-id="1*b31hiO4ynbDLRrXWEFF4aQ.png" src="https://cdn-images-1.medium.com/max/800/1*b31hiO4ynbDLRrXWEFF4aQ.png" />
                        </figure>
                        <p name="a1f7" id="a1f7" class="graf graf--p graf-after--figure">
                            Like a stack of dirty plates in the sink. The first one you take
                            off the<br />top is the last one you put down.
                        </p>
                        <h3 name="3481" id="3481" class="graf graf--h3 graf-after--p">
                            Tree
                        </h3>
                        <p name="3362" id="3362" class="graf graf--p graf-after--h3">
                            Good for storing hierarchies. Each node can have “child” nodes.
                        </p>
                        <figure name="c293" id="c293" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-image-id="1*b31hiO4ynbDLRrXWEFF4aQ.png" src="https://cdn-images-1.medium.com/max/800/1*b31hiO4ynbDLRrXWEFF4aQ.png" />
                        </figure>
                        <figure name="53de" id="53de" class="graf graf--figure graf-after--figure">
                            <img class="graf-image" data-image-id="1*b31hiO4ynbDLRrXWEFF4aQ.png" src="https://cdn-images-1.medium.com/max/800/1*b31hiO4ynbDLRrXWEFF4aQ.png" />
                        </figure>
                        <figure name="6acd" id="6acd" class="graf graf--figure graf-after--figure">
                            <img class="graf-image" data-image-id="1*b31hiO4ynbDLRrXWEFF4aQ.png" src="https://cdn-images-1.medium.com/max/800/1*b31hiO4ynbDLRrXWEFF4aQ.png" />
                        </figure>
                        <figure name="ba1e" id="ba1e" class="graf graf--figure graf-after--figure">
                            <img class="graf-image" data-image-id="1*b31hiO4ynbDLRrXWEFF4aQ.png" src="https://cdn-images-1.medium.com/max/800/1*b31hiO4ynbDLRrXWEFF4aQ.png" />
                        </figure>
                        <figure name="eac1" id="eac1" class="graf graf--figure graf-after--figure">
                            <img class="graf-image" data-image-id="1*b31hiO4ynbDLRrXWEFF4aQ.png" src="https://cdn-images-1.medium.com/max/800/1*b31hiO4ynbDLRrXWEFF4aQ.png" />
                        </figure>
                        <figure name="6ed9" id="6ed9" class="graf graf--figure graf-after--figure">
                            <img class="graf-image" data-image-id="1*b31hiO4ynbDLRrXWEFF4aQ.png" src="https://cdn-images-1.medium.com/max/800/1*b31hiO4ynbDLRrXWEFF4aQ.png" />
                        </figure>
                        <h3 name="6193" id="6193" class="graf graf--h3 graf-after--figure">
                            Binary Search Tree
                        </h3>
                        <p name="600d" id="600d" class="graf graf--p graf-after--h3">
                            Everything in the left subtree is smaller than the current
                            node,<br />everything in the right subtree is larger. lookups,
                            but only if the tree<br />is balanced!
                        </p>
                        <figure name="9b50" id="9b50" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-image-id="1*b31hiO4ynbDLRrXWEFF4aQ.png" src="https://cdn-images-1.medium.com/max/800/1*b31hiO4ynbDLRrXWEFF4aQ.png" />
                        </figure>
                        <h3 name="ffdf" id="ffdf" class="graf graf--h3 graf-after--figure">
                            Binary Search Tree
                        </h3>
                        <h3 name="c539" id="c539" class="graf graf--h3 graf-after--h3">
                            Graph
                        </h3>
                        <p name="9b47" id="9b47" class="graf graf--p graf-after--h3">
                            Good for storing networks, geography, social relationships, etc.
                        </p>
                        <figure name="6e0b" id="6e0b" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-image-id="1*b31hiO4ynbDLRrXWEFF4aQ.png" src="https://cdn-images-1.medium.com/max/800/1*b31hiO4ynbDLRrXWEFF4aQ.png" />
                        </figure>
                        <figure name="1112" id="1112" class="graf graf--figure graf-after--figure">
                            <img class="graf-image" data-image-id="1*b31hiO4ynbDLRrXWEFF4aQ.png" src="https://cdn-images-1.medium.com/max/800/1*b31hiO4ynbDLRrXWEFF4aQ.png" />
                        </figure>
                        <figure name="1480" id="1480" class="graf graf--figure graf-after--figure">
                            <img class="graf-image" data-image-id="1*b31hiO4ynbDLRrXWEFF4aQ.png" src="https://cdn-images-1.medium.com/max/800/1*b31hiO4ynbDLRrXWEFF4aQ.png" />
                        </figure>
                        <h3 name="bd89" id="bd89" class="graf graf--h3 graf-after--figure">
                            Heap
                        </h3>
                        <p name="b0c8" id="b0c8" class="graf graf--p graf-after--h3">
                            A binary tree where the smallest value is always at the top. Use
                            it to implement a priority queue.
                        </p>
                        <p name="7036" id="7036" class="graf graf--p graf-after--p">
                            ![A binary heap is a binary tree where the nodes are organized
                            to so that the smallest value is always at the top.]
                        </p>
                        <h3 name="ba21" id="ba21" class="graf graf--h3 graf-after--p">
                            Adjacency list
                        </h3>
                        <p name="a4b4" id="a4b4" class="graf graf--p graf-after--h3">
                            A list where the index represents the node and the value at that
                            index is a list of the node’s neighbors:
                        </p>
                        <p name="89e0" id="89e0" class="graf graf--p graf-after--p">
                            graph = [ [1], [0, 2, 3], [1, 3], [1, 2], ]
                        </p>
                        <p name="ed97" id="ed97" class="graf graf--p graf-after--p">
                            Since node 3 has edges to nodes 1 and 2, graph[3] has the
                            adjacency list [1, 2].
                        </p>
                        <p name="5345" id="5345" class="graf graf--p graf-after--p">
                            We could also use
                            <a href="https://www.interviewcake.com/concept/hash-map" data-href="https://www.interviewcake.com/concept/hash-map" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">a dictionary</a>
                            where the keys represent the node and the values are the lists
                            of neighbors.
                        </p>
                        <p name="a3a5" id="a3a5" class="graf graf--p graf-after--p">
                            graph = { 0: [1], 1: [0, 2, 3], 2: [1, 3], 3: [1, 2], }
                        </p>
                        <p name="6435" id="6435" class="graf graf--p graf-after--p">
                            This would be useful if the nodes were represented by strings,
                            objects, or otherwise didn’t map cleanly to list indices.
                        </p>
                        <h3 name="fd5b" id="fd5b" class="graf graf--h3 graf-after--p">
                            Adjacency matrix
                        </h3>
                        <p name="8da1" id="8da1" class="graf graf--p graf-after--h3">
                            A matrix of 0s and 1s indicating whether node x connects to node
                            y (0 means no, 1 means yes).
                        </p>
                        <p name="47a7" id="47a7" class="graf graf--p graf-after--p">
                            graph = [ [0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1,
                            0], ]
                        </p>
                        <p name="02c2" id="02c2" class="graf graf--p graf-after--p">
                            Since node 3 has edges to nodes 1 and 2, graph[3][1] and
                            graph[3][2] have value 1.
                        </p>
                        <p name="ed02" id="ed02" class="graf graf--p graf-after--p graf--trailing">
                            a = LinkedListNode(5) b = LinkedListNode(1) c =
                            LinkedListNode(9) a.next = b b.next = c
                        </p>
                    </div>
                </div>
            </section>
            <section name="6c67" class="section section--body">
                <div class="section-divider">
                    <hr class="section-divider" />
                </div>
                <div class="section-content">
                    <div class="section-inner sectionLayout--insetColumn">
                        <h3 name="6a73" id="6a73" class="graf graf--h3 graf--leading">
                            Arrays
                        </h3>
                        <p name="2df3" id="2df3" class="graf graf--p graf-after--h3">
                            Ok, so we know how to store individual numbers. Let’s talk about
                            storing
                            <em class="markup--em markup--p-em">several numbers</em>.
                        </p>
                        <p name="e1cd" id="e1cd" class="graf graf--p graf-after--p">
                            That’s right, things are starting to
                            <em class="markup--em markup--p-em">heat up</em>.
                        </p>
                        <p name="aac6" id="aac6" class="graf graf--p graf-after--p">
                            Suppose we wanted to keep a count of how many bottles of
                            kombucha we drink every day.
                        </p>
                        <p name="98ce" id="98ce" class="graf graf--p graf-after--p">
                            Let’s store each day’s kombucha count in an 8-bit, fixed-width,
                            unsigned integer. That should be plenty — we’re not likely to
                            get through more than 256 (2⁸) bottles in a
                            <em class="markup--em markup--p-em">single day</em>, right?
                        </p>
                        <p name="dd42" id="dd42" class="graf graf--p graf-after--p">
                            And let’s store the kombucha counts right next to each other in
                            RAM, starting at memory address 0:
                        </p>
                        <figure name="8536" id="8536" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-image-id="1*b31hiO4ynbDLRrXWEFF4aQ.png" src="https://cdn-images-1.medium.com/max/800/1*b31hiO4ynbDLRrXWEFF4aQ.png" />
                        </figure>
                        <p name="913b" id="913b" class="graf graf--p graf-after--figure">
                            Bam. That’s an
                            <strong class="markup--strong markup--p-strong">array</strong>.
                            RAM is <em class="markup--em markup--p-em">basically</em> an
                            array already.
                        </p>
                        <p name="9b44" id="9b44" class="graf graf--p graf-after--p">
                            Just like with RAM, the elements of an array are numbered. We
                            call that number the
                            <strong class="markup--strong markup--p-strong">index</strong>
                            of the array element (plural: indices). In
                            <em class="markup--em markup--p-em">this</em> example, each
                            array element’s index is the same as its address in RAM.
                        </p>
                        <p name="4748" id="4748" class="graf graf--p graf-after--p">
                            But that’s not usually true. Suppose another program like
                            Spotify had already stored some information at memory address 2:
                        </p>
                        <figure name="6da8" id="6da8" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--Y_RMWuhn--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__array5_occupied.svg%3Fbust%3D209" alt="A column of 9 RAM slots representing an array. The row at index 2 is highlighted because it is being used by Spotify." />
                        </figure>
                        <p name="c0fa" id="c0fa" class="graf graf--p graf-after--figure">
                            We’d have to start our array below it, for example at memory
                            address 3. So index 0 in our array would be at memory address 3,
                            and index 1 would be at memory address 4, etc.:
                        </p>
                        <figure name="94f0" id="94f0" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--BlipC0Dd--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__array5.svg%3Fbust%3D209" alt="A column of 9 RAM slots representing an array. The row at index 2 is highlighted, and the rows at indices 3 through 7 are selected with a bracket." />
                        </figure>
                        <p name="5335" id="5335" class="graf graf--p graf-after--figure">
                            Suppose we wanted to get the kombucha count at index 4 in our
                            array. How do we figure out what
                            <em class="markup--em markup--p-em">address in memory</em> to go
                            to? Simple math:
                        </p>
                        <p name="a2ca" id="a2ca" class="graf graf--p graf-after--p">
                            Take the array’s starting address (3), add the index we’re
                            looking for (4), and that’s the address of the item we’re
                            looking for. 3 + 4 = 7. In general, for getting the nth item in
                            our array:
                        </p>
                        <p name="5092" id="5092" class="graf graf--p graf-after--p">
                            \text{address of nth item in array} = \text{address of array
                            start} + n
                        </p>
                        <p name="8672" id="8672" class="graf graf--p graf-after--p">
                            This works out nicely because the size of the addressed memory
                            slots and the size of each kombucha count are
                            <em class="markup--em markup--p-em">both</em> 1 byte. So a slot
                            in our array corresponds to a slot in RAM.
                        </p>
                        <p name="03f6" id="03f6" class="graf graf--p graf-after--p">
                            But that’s not always the case. In fact, it’s
                            <em class="markup--em markup--p-em">usually not</em> the case.
                            We <em class="markup--em markup--p-em">usually</em> use
                            <em class="markup--em markup--p-em">64-bit</em> integers.
                        </p>
                        <p name="eb59" id="eb59" class="graf graf--p graf-after--p">
                            So how do we build an array of
                            <em class="markup--em markup--p-em">64-bit</em> (8 byte)
                            integers on top of our
                            <em class="markup--em markup--p-em">8-bit</em> (1 byte) memory
                            slots?
                        </p>
                        <p name="0068" id="0068" class="graf graf--p graf-after--p">
                            We simply give each array index
                            <em class="markup--em markup--p-em">8</em> address slots instead
                            of 1:
                        </p>
                        <figure name="b4b1" id="b4b1" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--gT5d0HB9--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__array64_long.svg%3Fbust%3D209" alt="A column of RAM slots representing an array of 64-bit integers. Every 8 buckets of RAM represents one integer." />
                        </figure>
                        <p name="7984" id="7984" class="graf graf--p graf-after--figure">
                            So we can still use simple math to grab the start of the nth
                            item in our array — just gotta throw in some multiplication:
                        </p>
                        <p name="ca4e" id="ca4e" class="graf graf--p graf-after--p">
                            \text{address of nth item in array} = \text{address of array
                            start} + (n * \text{size of each item in bytes})
                        </p>
                        <p name="c0b4" id="c0b4" class="graf graf--p graf-after--p">
                            Don’t worry — adding this multiplication doesn’t really slow us
                            down. Remember: addition, subtraction, multiplication, and
                            division of fixed-width integers takes time. So
                            <em class="markup--em markup--p-em">all</em> the math we’re
                            using here to get the address of the nth item in the array takes
                            time.
                        </p>
                        <p name="379c" id="379c" class="graf graf--p graf-after--p">
                            And remember how we said the memory controller has a
                            <em class="markup--em markup--p-em">direct connection</em> to
                            each slot in RAM? That means we can read the stuff at any given
                            memory address in time.
                        </p>
                        <figure name="7d87" id="7d87" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--7WCAMdWI--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__arrays_no_processor_ram_memory_controller.svg%3Fbust%3D209" alt="A memory controller connected to a section of RAM." />
                        </figure>
                        <p name="80d5" id="80d5" class="graf graf--p graf-after--figure">
                            <strong class="markup--strong markup--p-strong">Together, this means looking up the contents of a given array
                                index is time.</strong>
                            This fast lookup capability is the most important property of
                            arrays.
                        </p>
                        <p name="a2f2" id="a2f2" class="graf graf--p graf-after--p">
                            But the formula we used to get the address of the nth item in
                            our array only works
                            <em class="markup--em markup--p-em">if</em>:
                        </p>
                        <ol class="postList">
                            <li name="775e" id="775e" class="graf graf--li graf-after--p">
                                <strong class="markup--strong markup--li-strong">Each item in the array is the
                                    <em class="markup--em markup--li-em">same size</em></strong>
                                (takes up the same
                            </li>
                        </ol>
                        <p name="1444" id="1444" class="graf graf--p graf-after--li">
                            number of bytes).
                        </p>
                        <ol class="postList">
                            <li name="bdaa" id="bdaa" class="graf graf--li graf-after--p">
                                <strong class="markup--strong markup--li-strong">The array is
                                    <em class="markup--em markup--li-em">uninterrupted</em>
                                    (contiguous) in memory</strong>. There can’t
                            </li>
                        </ol>
                        <p name="ed24" id="ed24" class="graf graf--p graf-after--li">
                            be any gaps in the array…like to “skip over” a memory slot
                            Spotify was already using.
                        </p>
                        <p name="f38f" id="f38f" class="graf graf--p graf-after--p">
                            These things make our formula for finding the nth item
                            <em class="markup--em markup--p-em">work</em> because they make
                            our array <em class="markup--em markup--p-em">predictable</em>.
                            We can <em class="markup--em markup--p-em">predict</em> exactly
                            where in memory the nth element of our array will be.
                        </p>
                        <p name="373e" id="373e" class="graf graf--p graf-after--p">
                            But they also constrain what kinds of things we can put in an
                            array. Every item has to be the same size. And if our array is
                            going to store a <em class="markup--em markup--p-em">lot</em> of
                            stuff, we’ll need a
                            <em class="markup--em markup--p-em">bunch</em> of uninterrupted
                            free space in RAM. Which gets hard when most of our RAM is
                            already occupied by other programs (like Spotify).
                        </p>
                        <p name="a3ff" id="a3ff" class="graf graf--p graf-after--p graf--trailing">
                            That’s the tradeoff. Arrays have fast lookups ( time), but each
                            item in the array needs to be the same size, and you need a big
                            block of uninterrupted free memory to store the array.
                        </p>
                    </div>
                </div>
            </section>
            <section name="267f" class="section section--body">
                <div class="section-divider">
                    <hr class="section-divider" />
                </div>
                <div class="section-content">
                    <div class="section-inner sectionLayout--insetColumn">
                        <p name="081a" id="081a" class="graf graf--p graf--leading">
                            ## Pointers
                        </p>
                        <p name="5c5d" id="5c5d" class="graf graf--p graf-after--p">
                            Remember how we said every item in an array had to be the same
                            size? Let’s dig into that a little more.
                        </p>
                        <p name="d61c" id="d61c" class="graf graf--p graf-after--p">
                            Suppose we wanted to store a bunch of ideas for baby names.
                            Because we’ve got some
                            <em class="markup--em markup--p-em">really</em> cute ones.
                        </p>
                        <p name="14f0" id="14f0" class="graf graf--p graf-after--p">
                            Each name is a string. Which is really an array. And now we want
                            to store
                            <em class="markup--em markup--p-em">those arrays</em> in an
                            array. <em class="markup--em markup--p-em">Whoa</em>.
                        </p>
                        <p name="bb34" id="bb34" class="graf graf--p graf-after--p">
                            Now, what if our baby names have different lengths? That’d
                            violate our rule that all the items in an array need to be the
                            same size!
                        </p>
                        <p name="66fc" id="66fc" class="graf graf--p graf-after--p">
                            We could put our baby names in arbitrarily large arrays (say, 13
                            characters each), and just use a special character to mark the
                            end of the string within each array…
                        </p>
                        <figure name="d470" id="d470" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--qCseyyZT--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__pointers_baby_names.svg%3Fbust%3D209" alt='Strings represented in RAM as arrays of 13 characters, with the end of the strings being denoted by a special "null" character. The last 8 rows are marked as wasted space because the name Bill (along with the null character) only takes up 5 out of 13 available characters.' />
                        </figure>
                        <p name="6dbe" id="6dbe" class="
                  graf graf--p graf--startsWithDoubleQuote
                  graf-after--figure
                ">
                            “Wigglesworth” is a cute baby name, right?
                        </p>
                        <p name="e7c2" id="e7c2" class="graf graf--p graf-after--p">
                            But look at all that wasted space after “Bill”. And what if we
                            wanted to store a string that was
                            <em class="markup--em markup--p-em">more</em> than 13
                            characters? We’d be out of luck.
                        </p>
                        <p name="10e2" id="10e2" class="graf graf--p graf-after--p">
                            There’s a better way. Instead of storing the strings right
                            inside our array, let’s just put the strings wherever we can fit
                            them in memory. Then we’ll have each element in our array hold
                            the
                            <em class="markup--em markup--p-em">address in memory</em> of
                            its corresponding string. Each address is an integer, so really
                            our outer array is just an array of integers. We can call each
                            of these integers a
                            <strong class="markup--strong markup--p-strong">pointer</strong>, since it points to another spot in memory.
                        </p>
                        <figure name="1078" id="1078" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--uGtZJDDB--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__pointers_pointer_array.svg%3Fbust%3D209" alt="An array of names represented in RAM. The names are stored out of order, but an array holds the address in memory of each of name with arrows pointing from the number to the memory address." />
                        </figure>
                        <p name="62dd" id="62dd" class="graf graf--p graf-after--figure">
                            The pointers are marked with a * at the beginning.
                        </p>
                        <p name="6776" id="6776" class="graf graf--p graf-after--p">
                            Pretty clever, right? This fixes
                            <em class="markup--em markup--p-em">both</em> the disadvantages
                            of arrays:
                        </p>
                        <ol class="postList">
                            <li name="5f20" id="5f20" class="graf graf--li graf-after--p">
                                The items don’t have to be the same length — each string can
                                be as
                            </li>
                        </ol>
                        <p name="fa93" id="fa93" class="graf graf--p graf-after--li">
                            long or as short as we want.
                        </p>
                        <ol class="postList">
                            <li name="87d1" id="87d1" class="graf graf--li graf-after--p">
                                We don’t need enough uninterrupted free memory to store all
                                our
                            </li>
                        </ol>
                        <p name="2447" id="2447" class="graf graf--p graf-after--li">
                            strings next to each other — we can place each of them
                            separately, wherever there’s space in RAM.
                        </p>
                        <p name="6149" id="6149" class="graf graf--p graf-after--p">
                            We fixed it! No more tradeoffs. Right?
                        </p>
                        <p name="83f1" id="83f1" class="graf graf--p graf-after--p">
                            Nope. Now we have a
                            <em class="markup--em markup--p-em">new</em> tradeoff:
                        </p>
                        <p name="d763" id="d763" class="graf graf--p graf-after--p">
                            Remember how the memory controller sends the contents of
                            <em class="markup--em markup--p-em">nearby</em> memory addresses
                            to the processor with each read? And the processor caches them?
                            So reading sequential addresses in RAM is
                            <em class="markup--em markup--p-em">faster</em> because we can
                            get most of those reads right from the cache?
                        </p>
                        <figure name="1ac4" id="1ac4" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--bBSI1vQ0--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__ram_cache.svg%3Fbust%3D209" alt="A series of caches inside of the memory controller, where the processor stores what it has recently read from RAM." />
                        </figure>
                        <p name="4b22" id="4b22" class="graf graf--p graf-after--figure">
                            Our original array was very
                            <strong class="markup--strong markup--p-strong">cache-friendly</strong>, because everything was sequential. So reading from the 0th
                            index, then the 1st index, then the 2nd, etc. got an extra
                            speedup from the processor cache.
                        </p>
                        <p name="c11e" id="c11e" class="graf graf--p graf-after--p">
                            <strong class="markup--strong markup--p-strong">But the pointers in this array make it
                                <em class="markup--em markup--p-em">not</em>
                                cache-friendly</strong>, because the baby names are scattered randomly around RAM. So
                            reading from the 0th index, then the 1st index, etc. doesn’t get
                            that extra speedup from the cache.
                        </p>
                        <p name="0572" id="0572" class="graf graf--p graf-after--p">
                            That’s the tradeoff. This pointer-based array requires less
                            uninterrupted memory and can accommodate elements that aren’t
                            all the same size,
                            <em class="markup--em markup--p-em">but</em> it’s
                            <em class="markup--em markup--p-em">slower</em> because it’s not
                            cache-friendly.
                        </p>
                        <p name="d988" id="d988" class="graf graf--p graf-after--p graf--trailing">
                            This slowdown isn’t reflected in the big O time cost. Lookups in
                            this pointer-based array are
                            <em class="markup--em markup--p-em">still</em> time.
                        </p>
                    </div>
                </div>
            </section>
            <section name="33a6" class="section section--body">
                <div class="section-divider">
                    <hr class="section-divider" />
                </div>
                <div class="section-content">
                    <div class="section-inner sectionLayout--insetColumn">
                        <h3 name="698e" id="698e" class="graf graf--h3 graf--leading">
                            Linked lists
                        </h3>
                        <p name="0e3d" id="0e3d" class="graf graf--p graf-after--h3">
                            Our word processor is definitely going to need fast
                            appends — appending to the document is like the
                            <em class="markup--em markup--p-em">main thing</em> you do with
                            a word processor.
                        </p>
                        <p name="7455" id="7455" class="graf graf--p graf-after--p">
                            Can we build a data structure that can store a string, has fast
                            appends, <em class="markup--em markup--p-em">and</em> doesn’t
                            require you to say how long the string will be ahead of time?
                        </p>
                        <p name="03e9" id="03e9" class="graf graf--p graf-after--p">
                            Let’s focus first on not having to know the length of our string
                            ahead of time. Remember how we used
                            <em class="markup--em markup--p-em">pointers</em> to get around
                            length issues with our array of baby names?
                        </p>
                        <p name="da21" id="da21" class="graf graf--p graf-after--p">
                            What if we pushed that idea even further?
                        </p>
                        <p name="53aa" id="53aa" class="graf graf--p graf-after--p">
                            What if each
                            <em class="markup--em markup--p-em">character</em> in our string
                            were a
                            <em class="markup--em markup--p-em">two-index array</em> with:
                        </p>
                        <ol class="postList">
                            <li name="76b9" id="76b9" class="graf graf--li graf-after--p">
                                the character itself 2. a pointer to the next character
                            </li>
                        </ol>
                        <figure name="735b" id="735b" class="graf graf--figure graf-after--li">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--YNLryv1z--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__linked_lists_sample.svg%3Fbust%3D209" alt='An example of a linked list storing the string "DEAR." Each element of the linked list is an array composed of two items: a character and a pointer that points to the next element.' />
                        </figure>
                        <p name="87ea" id="87ea" class="graf graf--p graf-after--figure">
                            We would call each of these two-item arrays a
                            <strong class="markup--strong markup--p-strong">node</strong>
                            and we’d call this series of nodes a
                            <strong class="markup--strong markup--p-strong">linked list</strong>.
                        </p>
                        <p name="cecb" id="cecb" class="graf graf--p graf-after--p">
                            Here’s how we’d actually implement it in memory:
                        </p>
                        <figure name="1394" id="1394" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--6WmTzLHY--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__linked_lists_in_memory.svg%3Fbust%3D209" alt="The same linked list represented in RAM, showing the nodes scattered in memory but connected by pointers." />
                        </figure>
                        <p name="7dd0" id="7dd0" class="graf graf--p graf-after--figure">
                            Notice how we’re free to store our nodes wherever we can find
                            two open slots in memory. They don’t have to be next to each
                            other. They don’t even have to be
                            <em class="markup--em markup--p-em">in order</em>:
                        </p>
                        <figure name="9839" id="9839" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--ehn3S37S--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__linked_lists_in_memory_out_of_order.svg%3Fbust%3D209" alt="The same linked list represented in RAM. This time the characters are stored out of order to show that the pointers still keep everything in place." />
                        </figure>
                        <p name="cf8c" id="cf8c" class="
                  graf graf--p graf--startsWithDoubleQuote
                  graf-after--figure
                ">
                            “But that’s not cache-friendly, “ you may be thinking. Good
                            point! We’ll get to that.
                        </p>
                        <p name="e479" id="e479" class="graf graf--p graf-after--p">
                            The first node of a linked list is called the
                            <strong class="markup--strong markup--p-strong">head</strong>,
                            and the last node is usually called the
                            <strong class="markup--strong markup--p-strong">tail</strong>.
                        </p>
                        <p name="afd9" id="afd9" class="graf graf--p graf-after--p">
                            Confusingly, some people prefer to use “tail” to refer to
                            <em class="markup--em markup--p-em">everything after the head</em>
                            of a linked list. In an interview it’s fine to use either
                            definition. Briefly say which definition you’re using, just to
                            be clear.
                        </p>
                        <p name="d54f" id="d54f" class="graf graf--p graf-after--p">
                            It’s important to have a pointer variable referencing the head
                            of the list — otherwise we’d be unable to find our way back to
                            the start of the list!
                        </p>
                        <p name="975e" id="975e" class="graf graf--p graf-after--p">
                            We’ll also sometimes keep a pointer to the tail. That comes in
                            handy when we want to add something new to the end of the linked
                            list. In fact, let’s try that out:
                        </p>
                        <p name="0e91" id="0e91" class="graf graf--p graf-after--p">
                            Suppose we had the string “LOG” stored in a linked list:
                        </p>
                        <figure name="b46f" id="b46f" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--mfaBbzFz--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__linked_lists_log_string.svg%3Fbust%3D209" alt='A linked list with head and tail pointers storing the word "LOG." The *head points to the first character "L, " and the tail points to the last letter "G."' />
                        </figure>
                        <p name="c103" id="c103" class="graf graf--p graf-after--figure">
                            Suppose we wanted to add an “S” to the end, to make it “LOGS”.
                            How would we do that?
                        </p>
                        <p name="eb8d" id="eb8d" class="graf graf--p graf-after--p">
                            Easy. We just put it in a new node:
                        </p>
                        <figure name="834e" id="834e" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--oXilln4p--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__linked_lists_log_string_add_node.svg%3Fbust%3D209" alt='A linked list with head and tail pointers storing the word "LOG." A new unconnected node storing the character "S" is added to the bottom and bolded.' />
                        </figure>
                        <p name="203b" id="203b" class="graf graf--p graf-after--figure">
                            And tweak some pointers:
                        </p>
                        <p name="c581" id="c581" class="graf graf--p graf-after--p">
                            ​1. Grab the last letter, which is “G”. Our tail pointer lets us
                            do this in time.
                        </p>
                        <figure name="1ed9" id="1ed9" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--AVcvz2xS--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__linked_lists_logs_string_grab_last_letter.svg%3Fbust%3D209" alt='A linked list with head and tail pointers storing the word "LOG." The *tail pointer and the character "G" are bolded.' />
                        </figure>
                        <p name="e253" id="e253" class="graf graf--p graf-after--figure">
                            ​2. Point the last letter’s next to the letter we’re appending
                            (“S”).
                        </p>
                        <figure name="736f" id="736f" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--S-1lIhy3--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__linked_lists_logs_string_point_next.svg%3Fbust%3D209" alt='A linked list with head and tail pointers storing the word "LOG." The "G"&#39;s *next pointer is bolded and pointing to the appended "S".' />
                        </figure>
                        <p name="5172" id="5172" class="graf graf--p graf-after--figure">
                            ​3. Update the tail pointer to point to our
                            <em class="markup--em markup--p-em">new</em> last letter, “S”.
                        </p>
                        <figure name="60b4" id="60b4" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--JmllFyxD--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__linked_lists_logs_string_tweak_pointers.svg%3Fbust%3D209" alt='A linked list with head and tail pointers storing the word "LOGS." The *tail pointer is now pointed to the new last letter: "S".' />
                        </figure>
                        <p name="433e" id="433e" class="graf graf--p graf-after--figure">
                            That’s time.
                        </p>
                        <p name="79ea" id="79ea" class="graf graf--p graf-after--p">
                            Why is it time? Because the runtime doesn’t get bigger if the
                            string gets bigger. No matter how many characters are in our
                            string, we still just have to tweak a couple pointers for any
                            append.
                        </p>
                        <p name="ac61" id="ac61" class="graf graf--p graf-after--p">
                            Now, what if instead of a linked list, our string had been a
                            <em class="markup--em markup--p-em">dynamic array</em>? We might
                            not have any room at the end, forcing us to do one of those
                            doubling operations to make space:
                        </p>
                        <figure name="1045" id="1045" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--yNf1nnQ6--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__linked_lists_log_string_doubled_array.svg%3Fbust%3D209" alt='A dynamic array containing the word "LOG" going through a doubling operation to make space for an appended letter.' />
                        </figure>
                        <p name="3359" id="3359" class="graf graf--p graf-after--figure">
                            So with a dynamic array, our append would have a
                            <em class="markup--em markup--p-em">worst-case</em> time cost
                            of .
                        </p>
                        <p name="8246" id="8246" class="graf graf--p graf-after--p">
                            <strong class="markup--strong markup--p-strong">Linked lists have worst-case -time appends, which is better
                                than the worst-case time of dynamic arrays.</strong>
                        </p>
                        <p name="4478" id="4478" class="graf graf--p graf-after--p">
                            That <em class="markup--em markup--p-em">worst-case</em> part is
                            important. The
                            <em class="markup--em markup--p-em">average case</em> runtime
                            for appends to linked lists and dynamic arrays is the same: .
                        </p>
                        <p name="ab0a" id="ab0a" class="graf graf--p graf-after--p">
                            Now, what if we wanted to *pre*pend something to our string?
                            Let’s say we wanted to put a “B” at the beginning.
                        </p>
                        <p name="6779" id="6779" class="graf graf--p graf-after--p">
                            For our linked list, it’s just as easy as appending. Create the
                            node:
                        </p>
                        <figure name="92eb" id="92eb" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--7Vz73gHn--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__linked_lists_logs_string_add_node.svg%3Fbust%3D209" alt='A linked list with head and tail pointers storing the word "LOGS." A new unconnected node storing the character "B" is added to the top and bolded.' />
                        </figure>
                        <p name="daea" id="daea" class="graf graf--p graf-after--figure">
                            And tweak some pointers:
                        </p>
                        <ol class="postList">
                            <li name="d83d" id="d83d" class="graf graf--li graf-after--p">
                                Point “B”’s next to “L”. 2. Point the head to “B”.
                            </li>
                        </ol>
                        <figure name="b78b" id="b78b" class="graf graf--figure graf-after--li">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--1CmEV2S0--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__linked_lists_blogs_string_tweak_pointers.svg%3Fbust%3D209" alt='A linked list with head and tail pointers storing the word "LOGS." The "B"&#39;s *next pointer is bolded and pointing to the letter "L, " and the *head pointer is bolded and pointing to the prepended letter "B".' />
                        </figure>
                        <p name="13ff" id="13ff" class="graf graf--p graf-after--figure">
                            Bam. time again.
                        </p>
                        <p name="a2a6" id="a2a6" class="graf graf--p graf-after--p">
                            But if our string were a
                            <em class="markup--em markup--p-em">dynamic array</em>…
                        </p>
                        <figure name="312c" id="312c" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--YKXtncD2--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__linked_lists_log_string_dynamic_array.svg%3Fbust%3D209" alt='A dynamic array storing the string "LOGS."' />
                        </figure>
                        <p name="1d44" id="1d44" class="graf graf--p graf-after--figure">
                            And we wanted to add in that “B”:
                        </p>
                        <figure name="996b" id="996b" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--mfo6UdVx--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__linked_lists_log_string_dynamic_array_add_b.svg%3Fbust%3D209" alt='A dynamic array storing the string "LOGS." A bolded "B" is added above the array.' />
                        </figure>
                        <p name="625f" id="625f" class="graf graf--p graf-after--figure">
                            Eep. We have to
                            <em class="markup--em markup--p-em">make room</em> for the “B”!
                        </p>
                        <p name="71b2" id="71b2" class="graf graf--p graf-after--p">
                            We have to move
                            <em class="markup--em markup--p-em">each character</em> one
                            space down:
                        </p>
                        <figure name="c850" id="c850" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--bCziqk0P--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__linked_lists_log_string_dynamic_array_move_s.svg%3Fbust%3D209" alt='A dynamic array storing the string "LOGS" with the letter "B" floating above. The "S" is bolded with an arrow attached showing how the character is being moved one index up.' />
                        </figure>
                        <figure name="e7cf" id="e7cf" class="graf graf--figure graf-after--figure">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--UKXNvdJJ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__linked_lists_log_string_dynamic_array_move_g.svg%3Fbust%3D209" alt='A dynamic array storing the string "LOGS" with the letter "B" floating above. The "G" is bolded with an arrow attached showing how the character is being moved one index up.' />
                        </figure>
                        <figure name="42c1" id="42c1" class="graf graf--figure graf-after--figure">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--urvmRqYo--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__linked_lists_log_string_dynamic_array_move_o.svg%3Fbust%3D209" alt='A dynamic array storing the string "LOGS" with the letter "B" floating above. The "O" is bolded with an arrow attached showing how the character is being moved one index up.' />
                        </figure>
                        <figure name="33b8" id="33b8" class="graf graf--figure graf-after--figure">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--y5qitmtl--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__linked_lists_log_string_dynamic_array_move_l.svg%3Fbust%3D209" alt='A dynamic array storing the string "LOGS" with the letter "B" floating above. The "L" is bolded with an arrow attached showing how the character is being moved one index up.' />
                        </figure>
                        <p name="b76e" id="b76e" class="graf graf--p graf-after--figure">
                            <em class="markup--em markup--p-em">Now</em> we can drop the “B”
                            in there:
                        </p>
                        <figure name="41a5" id="41a5" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--k1cDvEK0--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__linked_lists_log_string_dynamic_array_chars_moved.svg%3Fbust%3D209" alt='A dynamic array storing the string "LOGS" with the letter "B" floating above. The "B" is bolded with an arrow attached showing how the character is now being placed in the first index.' />
                        </figure>
                        <p name="f73d" id="f73d" class="graf graf--p graf-after--figure">
                            What’s our time cost here?
                        </p>
                        <p name="8a55" id="8a55" class="graf graf--p graf-after--p">
                            It’s all in the step where we made room for the first letter. We
                            had to move
                            <em class="markup--em markup--p-em">all n</em> characters in our
                            string. One at a time. That’s time.
                        </p>
                        <p name="a74e" id="a74e" class="graf graf--p graf-after--p">
                            <strong class="markup--strong markup--p-strong">So linked lists have faster *pre*pends ( time) than dynamic
                                arrays ( time).</strong>
                        </p>
                        <p name="784a" id="784a" class="graf graf--p graf-after--p">
                            No “worst case” caveat this time — prepends for dynamic arrays
                            are <em class="markup--em markup--p-em">always</em> time. And
                            prepends for linked lists are
                            <em class="markup--em markup--p-em">always</em> time.
                        </p>
                        <p name="26f6" id="26f6" class="graf graf--p graf-after--p">
                            These quick appends and prepends for linked lists come from the
                            fact that linked list nodes can go anywhere in memory. They
                            don’t have to sit right next to each other the way items in an
                            array do.
                        </p>
                        <p name="e2fa" id="e2fa" class="graf graf--p graf-after--p">
                            So if linked lists are so great, why do we usually store strings
                            in an array?
                            <strong class="markup--strong markup--p-strong">Because </strong><a href="https://dev.to/bgoonz/everything-you-need-to-become-a-machine-learner-1cjp#constant-time-array-lookups" data-href="https://dev.to/bgoonz/everything-you-need-to-become-a-machine-learner-1cjp#constant-time-array-lookups" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">arrays have -time lookups</strong></a><strong class="markup--strong markup--p-strong">.</strong> And
                            those constant-time lookups
                            <em class="markup--em markup--p-em">come from</em> the fact that
                            all the array elements are lined up next to each other in
                            memory.
                        </p>
                        <p name="3f20" id="3f20" class="graf graf--p graf-after--p">
                            Lookups with a linked list are more of a process, because we
                            have no way of knowing where the ith node is in memory. So we
                            have to walk through the linked list node by node, counting as
                            we go, until we hit the ith item.
                        </p>
                        <p name="7913" id="7913" class="graf graf--p graf-after--p">
                            def get_ith_item_in_linked_list(head, i): if i &lt; 0: raise
                            ValueError(“i can’t be negative: %d” % i) current_node = head
                            current_position = 0 while current_node: if current_position ==
                            i: # Found it! return current_node # Move on to the next node
                            current_node = current_node.next current_position += 1 raise
                            ValueError(‘List has fewer than i + 1 (%d) nodes’ % (i + 1))
                        </p>
                        <p name="6881" id="6881" class="graf graf--p graf-after--p">
                            That’s i + 1 steps down our linked list to get to the ith node
                            (we made our function zero-based to match indices in arrays).
                            <strong class="markup--strong markup--p-strong">So linked lists have -time lookups.</strong>
                            Much slower than the -time lookups for arrays and dynamic
                            arrays.
                        </p>
                        <p name="6194" id="6194" class="graf graf--p graf-after--p">
                            Not only that — <strong class="markup--strong markup--p-strong">walking down a linked list is
                                <em class="markup--em markup--p-em">not</em>
                                cache-friendly.</strong>
                            Because the next node could be
                            <em class="markup--em markup--p-em">anywhere</em> in memory, we
                            don’t get any benefit from the processor cache. This means
                            lookups in a linked list are even slower.
                        </p>
                        <p name="c128" id="c128" class="graf graf--p graf-after--p graf--trailing">
                            So the tradeoff with linked lists is they have faster prepends
                            and faster appends than dynamic arrays,
                            <em class="markup--em markup--p-em">but</em> they have slower
                            lookups.
                        </p>
                    </div>
                </div>
            </section>
            <section name="0967" class="section section--body">
                <div class="section-divider">
                    <hr class="section-divider" />
                </div>
                <div class="section-content">
                    <div class="section-inner sectionLayout--insetColumn">
                        <p name="a156" id="a156" class="graf graf--p graf--leading">
                            ## Doubly Linked Lists
                        </p>
                        <p name="0f8d" id="0f8d" class="graf graf--p graf-after--p">
                            In a basic linked list, each item stores a single pointer to the
                            next element.
                        </p>
                        <p name="8c5f" id="8c5f" class="graf graf--p graf-after--p">
                            In a
                            <strong class="markup--strong markup--p-strong">doubly linked list</strong>, items have pointers to the next
                            <em class="markup--em markup--p-em">and the previous</em> nodes.
                        </p>
                        <figure name="d0cd" id="d0cd" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--W5wnVYSu--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/linked_list__doubly_linked_nodes_and_pointers.svg%3Fbust%3D209" alt='A doubly-linked list with 3 nodes. The first node has value 5 with a "next" arrow pointing ahead to the second node and a "previous" arrow pointing back to "None." The second node has value 1 with a "next" arrow pointing ahead to the third node and a "previous" arrow pointing back to the first node. The third node has value 9 with a "next" arrow pointing ahead to "None" and a "previous" arrow pointing back to the second node.' />
                        </figure>
                        <p name="b19f" id="b19f" class="graf graf--p graf-after--figure">
                            Doubly linked lists allow us to traverse our list
                            <em class="markup--em markup--p-em">backwards</em>. In a
                            <em class="markup--em markup--p-em">singly</em> linked list, if
                            you just had a pointer to a node in the
                            <em class="markup--em markup--p-em">middle</em> of a list, there
                            would be <em class="markup--em markup--p-em">no way</em> to know
                            what nodes came before it. Not a problem in a doubly linked
                            list.
                        </p>
                        <h3 name="da5b" id="da5b" class="graf graf--h3 graf-after--p">
                            Not cache-friendly
                        </h3>
                        <p name="9313" id="9313" class="graf graf--p graf-after--h3">
                            Most computers have
                            <a href="https://www.interviewcake.com/article/data-structures-coding-interview#ram" data-href="https://www.interviewcake.com/article/data-structures-coding-interview#ram" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">caching systems that make reading from sequential addresses
                                in memory faster than reading from scattered addresses</a>.
                        </p>
                        <p name="83d6" id="83d6" class="graf graf--p graf-after--p">
                            <a href="https://www.interviewcake.com/concept/array" data-href="https://www.interviewcake.com/concept/array" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Array</a>
                            items are always located right next to each other in computer
                            memory, but linked list nodes can be scattered all over.
                        </p>
                        <p name="c0eb" id="c0eb" class="graf graf--p graf-after--p graf--trailing">
                            So iterating through a linked list is usually quite a bit slower
                            than iterating through the items in an array, even though
                            they’re both theoretically time.
                        </p>
                    </div>
                </div>
            </section>
            <section name="f5bd" class="section section--body section--last">
                <div class="section-divider">
                    <hr class="section-divider" />
                </div>
                <div class="section-content">
                    <div class="section-inner sectionLayout--insetColumn">
                        <p name="df44" id="df44" class="graf graf--p graf--leading">
                            ## Hash tables
                        </p>
                        <p name="e883" id="e883" class="graf graf--p graf-after--p">
                            Quick lookups are often really important. For that reason, we
                            tend to use arrays (-time lookups) much more often than linked
                            lists (-time lookups).
                        </p>
                        <p name="cab9" id="cab9" class="graf graf--p graf-after--p">
                            For example, suppose we wanted to count how many times each
                            ASCII character appears in
                            <a href="https://raw.githubusercontent.com/GITenberg/The-Tragedy-of-Romeo-and-Juliet_1112/master/1112.txt" data-href="https://raw.githubusercontent.com/GITenberg/The-Tragedy-of-Romeo-and-Juliet_1112/master/1112.txt" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Romeo and Juliet</a>. How would we store those counts?
                        </p>
                        <p name="9f11" id="9f11" class="graf graf--p graf-after--p">
                            We can use arrays in a clever way here. Remember — characters
                            are just numbers. In ASCII (a common character encoding) ‘A’ is
                            65, ‘B’ is 66, etc.
                        </p>
                        <p name="02d1" id="02d1" class="graf graf--p graf-after--p">
                            So we can use the character(‘s number value) as the
                            <em class="markup--em markup--p-em">index</em> in our array, and
                            store the <em class="markup--em markup--p-em">count</em> for
                            that character
                            <em class="markup--em markup--p-em">at that index</em> in the
                            array:
                        </p>
                        <figure name="5f35" id="5f35" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--btmVCtHm--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__hash_tables_chars_to_ints.svg%3Fbust%3D209" alt="An array showing indices 63 through 68. To the left of the indices are the ASCII characters that correspond to the numeric indices with arrows pointing from each character to its corresponding number." />
                        </figure>
                        <p name="733f" id="733f" class="graf graf--p graf-after--figure">
                            With this array, we can look up (and edit) the count for any
                            character in constant time. Because we can access any index in
                            our array in constant time.
                        </p>
                        <p name="ebf7" id="ebf7" class="graf graf--p graf-after--p">
                            Something interesting is happening here — this array isn’t just
                            a list of values. This array is storing
                            <em class="markup--em markup--p-em">two</em> things: characters
                            and counts. The characters are
                            <em class="markup--em markup--p-em">implied</em> by the indices.
                        </p>
                        <p name="3b9a" id="3b9a" class="graf graf--p graf-after--p">
                            <strong class="markup--strong markup--p-strong">So we can think of an array as a
                                <em class="markup--em markup--p-em">table</em> with
                                <em class="markup--em markup--p-em">two columns</em>…except
                                you don’t really get to pick the values in one column (the
                                indices) — they’re always 0, 1, 2, 3, etc.</strong>
                        </p>
                        <p name="7085" id="7085" class="graf graf--p graf-after--p">
                            But what if we wanted to put
                            <em class="markup--em markup--p-em">any</em> value in that
                            column and still get quick lookups?
                        </p>
                        <p name="788f" id="788f" class="graf graf--p graf-after--p">
                            Suppose we wanted to count the number of times each
                            <em class="markup--em markup--p-em">word</em> appears in Romeo
                            and Juliet. Can we adapt our array?
                        </p>
                        <p name="6190" id="6190" class="graf graf--p graf-after--p">
                            Translating a
                            <em class="markup--em markup--p-em">character</em> into an array
                            index was easy. But we’ll have to do something more clever to
                            translate a <em class="markup--em markup--p-em">word</em> (a
                            string) into an array index…
                        </p>
                        <figure name="9718" id="9718" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--I8djxAoK--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__hash_tables_lies_key_unlabeled.svg%3Fbust%3D209" alt='A blank array except for the value 20 stored at index 9. To the left the array is the word "lies" with an arrow pointing to the right at diamond with a question mark in the middle. The diamond points to the 9th index of the array.' />
                        </figure>
                        <p name="81ea" id="81ea" class="graf graf--p graf-after--figure">
                            Here’s one way we could do it:
                        </p>
                        <p name="a4cf" id="a4cf" class="graf graf--p graf-after--p">
                            Grab the number value for each character and add those up.
                        </p>
                        <figure name="bbfb" id="bbfb" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--o_H9Avlc--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__hash_tables_lies_chars.svg%3Fbust%3D209" alt='The word "lies" in quotes. Arrows point from each character down to their corresponding number values, which are separated by plus signs and shown in sum to equal 429.' />
                        </figure>
                        <p name="2004" id="2004" class="graf graf--p graf-after--figure">
                            The result is 429. But what if we only have
                            <em class="markup--em markup--p-em">30</em> slots in our array?
                            We’ll use a common trick for forcing a number into a specific
                            range: the modulus operator (%). Modding our sum by 30 ensures
                            we get a whole number that’s less than 30 (and at least 0):
                        </p>
                        <p name="c452" id="c452" class="graf graf--p graf-after--p">
                            429 \: \% \: 30 = 9
                        </p>
                        <p name="8e1b" id="8e1b" class="graf graf--p graf-after--p">
                            Bam. That’ll get us from a word (or any string) to an array
                            index.
                        </p>
                        <p name="b04a" id="b04a" class="graf graf--p graf-after--p">
                            This data structure is called a
                            <strong class="markup--strong markup--p-strong">hash table</strong>
                            or
                            <strong class="markup--strong markup--p-strong">hash map</strong>. In our hash table, the
                            <em class="markup--em markup--p-em">counts</em> are the
                            <strong class="markup--strong markup--p-strong">values</strong>
                            and the <em class="markup--em markup--p-em">words</em> (“lies, “
                            etc.) are the
                            <strong class="markup--strong markup--p-strong">keys</strong>
                            (analogous to the
                            <em class="markup--em markup--p-em">indices</em> in an array).
                            The process we used to translate a key into an array index is
                            called a
                            <strong class="markup--strong markup--p-strong">hashing function</strong>.
                        </p>
                        <p name="603d" id="603d" class="graf graf--p graf-after--p">
                            ![A blank array except for a 20, labeled as the value, stored at
                            index
                        </p>
                        <ol class="postList">
                            <li name="e3bd" id="e3bd" class="graf graf--li graf-after--p">
                                To the left the array is the word “lies,” labeled as the key,
                                with an
                            </li>
                        </ol>
                        <p name="95b1" id="95b1" class="graf graf--p graf-after--li">
                            arrow pointing to the right at diamond with a question mark in
                            the middle, labeled as the hashing function. The diamond points
                            to the 9th index of the array.](<a href="https://www.interviewcake.com/images/svgs/cs_for_hackers__hash_tables_lies_key_labeled.svg?bust=209" data-href="https://www.interviewcake.com/images/svgs/cs_for_hackers__hash_tables_lies_key_labeled.svg?bust=209" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://www.interviewcake.com/images/svgs/cs_for_hackers__hash_tables_lies_key_labeled.svg?bust=209</a>)
                        </p>
                        <p name="edf4" id="edf4" class="graf graf--p graf-after--p">
                            The hashing functions used in modern systems get pretty
                            complicated — the one we used here is a simplified example.
                        </p>
                        <p name="b3c9" id="b3c9" class="graf graf--p graf-after--p">
                            Note that our quick lookups are only in one direction — we can
                            quickly get the value for a given key, but the only way to get
                            the key for a given value is to walk through all the values and
                            keys.
                        </p>
                        <p name="3aae" id="3aae" class="graf graf--p graf-after--p">
                            Same thing with arrays — we can quickly look up the value at a
                            given index, but the only way to figure out the index for a
                            given value is to walk through the whole array.
                        </p>
                        <p name="8f02" id="8f02" class="graf graf--p graf-after--p">
                            One problem — what if two keys hash to the same index in our
                            array? Look at “lies” and “foes”:
                        </p>
                        <figure name="d406" id="d406" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--hQya5wPd--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__hash_tables_lies_and_foes_addition.svg%3Fbust%3D209" alt='The word "lies" in quotes and the word "foes" in quotes. Arrows point from the characters of each word to their corresponding number values. The sum of the characters of both words is shown to equal 429.' />
                        </figure>
                        <p name="5404" id="5404" class="graf graf--p graf-after--figure">
                            They both sum up to 429! So of course they’ll have the same
                            answer when we mod by 30:
                        </p>
                        <p name="4f66" id="4f66" class="graf graf--p graf-after--p">
                            429 \: \% \: 30 = 9
                        </p>
                        <p name="a856" id="a856" class="graf graf--p graf-after--p">
                            So our hashing function gives us the same answer for “lies” and
                            “foes.” This is called a
                            <strong class="markup--strong markup--p-strong">hash collision</strong>. There are a few different strategies for dealing with them.
                        </p>
                        <p name="0383" id="0383" class="graf graf--p graf-after--p">
                            Here’s a common one: instead of storing the actual values in our
                            array, let’s have each array slot hold a
                            <em class="markup--em markup--p-em">pointer</em> to a
                            <em class="markup--em markup--p-em">linked list</em> holding the
                            counts for all the words that hash to that index:
                        </p>
                        <figure name="4ab7" id="4ab7" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--lAi8uw3W--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__hash_tables_hash_collision.svg%3Fbust%3D209" alt="An array storing pointers. Three of the pointers have arrows pointing to linked lists to the right of the array." />
                        </figure>
                        <p name="057d" id="057d" class="graf graf--p graf-after--figure">
                            One problem — how do we know which count is for “lies” and which
                            is for “foes”? To fix this, we’ll store the
                            <em class="markup--em markup--p-em">word</em> as well as the
                            count in each linked list node:
                        </p>
                        <figure name="c23a" id="c23a" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--S-aWhY-u--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__hash_tables_hash_collision_key_val.svg%3Fbust%3D209" alt="An array storing pointers. The pointer at index 9 has an arrow pointing to a linked list to the right of the array. Each linked list node now stores the word as well as its count and a pointer." />
                        </figure>
                        <p name="a0bc" id="a0bc" class="
                  graf graf--p graf--startsWithDoubleQuote
                  graf-after--figure
                ">
                            “But wait!” you may be thinking, “Now lookups in our hash table
                            take time in the worst case, since we have to walk down a linked
                            list.” That’s true! You could even say that in the worst case
                            <em class="markup--em markup--p-em">every</em> key creates a
                            hash collision, so our whole hash table
                            <em class="markup--em markup--p-em">degrades to a linked list</em>.
                        </p>
                        <p name="3016" id="3016" class="graf graf--p graf-after--p">
                            In industry though, we usually wave our hands and say
                            <strong class="markup--strong markup--p-strong">collisions are rare enough that on
                                <em class="markup--em markup--p-em">average</em> lookups in a
                                hash table are time</strong>. And there are fancy algorithms that keep the number of
                            collisions low and keep the lengths of our linked lists nice and
                            short.
                        </p>
                        <p name="bf5c" id="bf5c" class="graf graf--p graf-after--p">
                            But that’s sort of the tradeoff with hash tables. You get fast
                            lookups by key…except
                            <em class="markup--em markup--p-em">some</em> lookups could be
                            slow. And of course, you only get those fast lookups in one
                            direction — looking up the
                            <em class="markup--em markup--p-em">key</em> for a given
                            <em class="markup--em markup--p-em">value</em> still takes time
                        </p>
                        <h3 name="2caa" id="2caa" class="graf graf--h3 graf-after--p">
                            Breadth-First Search (BFS) and Breadth-First Traversal
                        </h3>
                        <p name="4dab" id="4dab" class="graf graf--p graf-after--h3">
                            <strong class="markup--strong markup--p-strong">Breadth-first search</strong>
                            (BFS) is a method for exploring a tree or graph. In a BFS, you
                            first explore all the nodes one step away, then all the nodes
                            two steps away, etc.
                        </p>
                        <p name="9bc7" id="9bc7" class="graf graf--p graf-after--p">
                            Breadth-first search is like throwing a stone in the center of a
                            pond. The nodes you explore “ripple out” from the starting
                            point.
                        </p>
                        <p name="b191" id="b191" class="graf graf--p graf-after--p">
                            Here’s a how a BFS would traverse this tree, starting with the
                            root:
                        </p>
                        <figure name="3699" id="3699" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--Ip0bjkja--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/breadth_first_search_root.svg%3Fbust%3D209" alt="A 4-row binary tree represented by circles connected with lines. Our breadth-first search has us start at the root node at the top of the tree." />
                        </figure>
                        <p name="be4b" id="be4b" class="graf graf--p graf-after--figure">
                            We’d visit all the immediate children (all the nodes that’re one
                            step away from our starting node):
                        </p>
                        <figure name="e936" id="e936" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--6rMlN7ZC--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/breadth_first_search_first_level.svg%3Fbust%3D209" alt="The same 4-row binary tree with all nodes at depth 1 (second row) bolded after being visited." />
                        </figure>
                        <p name="0902" id="0902" class="graf graf--p graf-after--figure">
                            Then we’d move on to all
                            <em class="markup--em markup--p-em">those</em> nodes’ children
                            (all the nodes that’re
                            <em class="markup--em markup--p-em">two steps</em> away from our
                            starting node):
                        </p>
                        <figure name="9da9" id="9da9" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--Sdzc1n9k--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/breadth_first_search_second_level.svg%3Fbust%3D209" alt="The same 4-row binary tree with all nodes at depth 2 (third row) bolded after being visited." />
                        </figure>
                        <p name="c234" id="c234" class="graf graf--p graf-after--figure">
                            And so on:
                        </p>
                        <figure name="205e" id="205e" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--wxWkBTNl--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/breadth_first_search_third_level.svg%3Fbust%3D209" alt="The same 4-row binary tree with all nodes at depth 3 (fourth and final row) bolded after being visited." />
                        </figure>
                        <p name="7cd3" id="7cd3" class="graf graf--p graf-after--figure">
                            Until we reach the end.
                        </p>
                        <p name="689a" id="689a" class="graf graf--p graf-after--p">
                            Breadth-first search is often compared with
                            <strong class="markup--strong markup--p-strong">depth-first search</strong>.
                        </p>
                        <p name="202f" id="202f" class="graf graf--p graf-after--p">
                            Advantages:
                        </p>
                        <ul class="postList">
                            <li name="3817" id="3817" class="graf graf--li graf-after--p">
                                A BFS will find the
                                <strong class="markup--strong markup--li-strong">shortest path</strong>
                                between the starting point and
                            </li>
                        </ul>
                        <p name="b3b4" id="b3b4" class="graf graf--p graf-after--li">
                            any other reachable node. A depth-first search will not
                            necessarily find the shortest path.
                        </p>
                        <p name="69a4" id="69a4" class="graf graf--p graf-after--p">
                            Disadvantages
                        </p>
                        <ul class="postList">
                            <li name="475a" id="475a" class="graf graf--li graf-after--p">
                                A BFS on a binary tree
                                <em class="markup--em markup--li-em">generally</em> requires
                                more memory than a DFS.
                            </li>
                        </ul>
                        <figure name="a674" id="a674" class="graf graf--figure graf-after--li">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--52hugl0W--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/binary_search_tree__preview.svg%3Fbust%3D209" alt="A binary search tree with nodes containing integers. The root node contains the integer 50. Each child node to the left of the root contains integers less than 50, and each child node to the right of the root contains integers greater than 50." />
                        </figure>
                        <h3 name="6afa" id="6afa" class="graf graf--h3 graf-after--figure">
                            Binary Search Tree
                        </h3>
                        <p name="df0b" id="df0b" class="graf graf--p graf-after--h3">
                            A
                            <strong class="markup--strong markup--p-strong">binary tree</strong>
                            is a
                            <strong class="markup--strong markup--p-strong">tree</strong>
                            where &lt;==(<strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">every node has two or fewer children</em></strong>)==&gt;.<br />The children are usually called
                            <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">left</em></strong>
                            and
                            <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">right</em></strong>.
                        </p>
                        <p name="98c1" id="98c1" class="graf graf--p graf-after--p">
                            class BinaryTreeNode(object):
                        </p>
                        <p name="c35b" id="c35b" class="graf graf--p graf-after--p">
                            This lets us build a structure like this:
                        </p>
                        <figure name="c5e5" id="c5e5" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--dnJM6hii--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/binary_tree__depth_5.svg%3Fbust%3D209" alt="A tree represented by circles connected with lines. The root node is on top, and connects to 2 children below it. Each of those children connect to 2 children below them, which all connect to their own 2 children, which all connect to their own 2 children." />
                        </figure>
                        <p name="3951" id="3951" class="graf graf--p graf-after--figure">
                            That particular example is special because every level of the
                            tree is completely full. There are no “gaps.” We call this kind
                            of tree “<strong class="markup--strong markup--p-strong">perfect</strong>.”
                        </p>
                        <p name="ead8" id="ead8" class="graf graf--p graf-after--p">
                            Binary trees have a few interesting properties when they’re
                            perfect:
                        </p>
                        <p name="2116" id="2116" class="graf graf--p graf-after--p">
                            <strong class="markup--strong markup--p-strong">Property 1: the number of total nodes on each “level” doubles
                                as we move down the tree.</strong>
                        </p>
                        <figure name="6076" id="6076" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--cL9Zb-jI--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/binary_tree__depth_5_with_number_of_nodes_labelled.svg%3Fbust%3D209" alt="A binary tree with 5 rows of nodes. The root node is on top, and every node has 2 children in the row below. Each row is labelled with the number of nodes in the row, which doubles from the top down: 1, 2, 4, 8, 16." />
                        </figure>
                        <p name="e60c" id="e60c" class="graf graf--p graf-after--figure">
                            <strong class="markup--strong markup--p-strong">Property 2: the number of nodes on the last level is equal to
                                the sum of the number of nodes on all other levels (plus
                                1).</strong>
                            In other words, about
                            <em class="markup--em markup--p-em">half</em> of our nodes are
                            on the last level.
                        </p>
                        <p name="aa88" id="aa88" class="graf graf--p graf-after--p">
                            &lt;==(<em class="markup--em markup--p-em">*Let’s call the number of nodes n, *</em>)==&gt;
                        </p>
                        <p name="0b4c" id="0b4c" class="graf graf--p graf-after--p">
                            &lt;==(<strong class="markup--strong markup--p-strong">_</strong>and the height of the tree h.
                            <strong class="markup--strong markup--p-strong">_</strong>)==&gt;
                        </p>
                        <p name="30f8" id="30f8" class="graf graf--p graf-after--p">
                            <strong class="markup--strong markup--p-strong">h can also be thought of as the “number of levels.”</strong>
                        </p>
                        <p name="bdb1" id="bdb1" class="graf graf--p graf-after--p">
                            If we had h, how could we calculate n?
                        </p>
                        <p name="41d1" id="41d1" class="graf graf--p graf-after--p">
                            Let’s just add up the number of nodes on each level!
                        </p>
                        <p name="fa13" id="fa13" class="graf graf--p graf-after--p">
                            If we zero-index the levels, the number of nodes on the xth
                            level is exactly 2^x.
                        </p>
                        <ol class="postList">
                            <li name="19ea" id="19ea" class="graf graf--li graf-after--p">
                                Level 0: 2⁰ nodes,
                            </li>
                            <li name="f30a" id="f30a" class="graf graf--li graf-after--li">
                                2. Level 1: 2¹ nodes,
                            </li>
                            <li name="2eb7" id="2eb7" class="graf graf--li graf-after--li">
                                3. Level 2: 2² nodes,
                            </li>
                            <li name="3e0b" id="3e0b" class="graf graf--li graf-after--li">
                                4. Level 3: 2³ nodes,
                            </li>
                            <li name="879b" id="879b" class="graf graf--li graf-after--li">
                                5. <em class="markup--em markup--li-em">etc</em>
                            </li>
                        </ol>
                        <p name="b9dc" id="b9dc" class="graf graf--p graf-after--li">
                            So our total number of nodes is:
                        </p>
                        <p name="0ef1" id="0ef1" class="graf graf--p graf-after--p">
                            <strong class="markup--strong markup--p-strong">n = 2⁰ + 2¹ + 2² + 2³ + … + 2^{h-1}</strong>
                        </p>
                        <p name="b579" id="b579" class="graf graf--p graf-after--p">
                            Why only up to 2^{h-1}?
                        </p>
                        <p name="222a" id="222a" class="graf graf--p graf-after--p">
                            Notice that we
                            <strong class="markup--strong markup--p-strong">started counting our levels at 0.</strong>
                        </p>
                        <ul class="postList">
                            <li name="cb44" id="cb44" class="graf graf--li graf-after--p">
                                So if we have h levels in total,
                            </li>
                            <li name="c2ec" id="c2ec" class="graf graf--li graf-after--li">
                                the last level is actually the “h-1”-th level.
                            </li>
                            <li name="c2ef" id="c2ef" class="graf graf--li graf-after--li">
                                That means the number of nodes on the last level is 2^{h-1}.
                            </li>
                        </ul>
                        <p name="d301" id="d301" class="graf graf--p graf-after--li">
                            But we can simplify.
                        </p>
                        <p name="60c0" id="60c0" class="graf graf--p graf-after--p">
                            <strong class="markup--strong markup--p-strong">Property 2 tells us that the number of nodes on the last
                                level is (1 more than) half of the total number of
                                nodes</strong>,
                        </p>
                        <p name="2a3d" id="2a3d" class="graf graf--p graf-after--p">
                            <strong class="markup--strong markup--p-strong">so we can just take the number of nodes on the last level,
                                multiply it by 2, and subtract 1 to get the number of nodes
                                overall</strong>.
                        </p>
                        <ul class="postList">
                            <li name="535d" id="535d" class="graf graf--li graf-after--p">
                                We know the number of nodes on the last level is 2^{h-1},
                            </li>
                            <li name="f28a" id="f28a" class="graf graf--li graf--empty graf-after--li">
                                <br />
                            </li>
                            <li name="2cc2" id="2cc2" class="graf graf--li graf-after--li">
                                So:
                            </li>
                            <li name="77df" id="77df" class="graf graf--li graf--empty graf-after--li">
                                <br />
                            </li>
                        </ul>
                        <p name="8298" id="8298" class="graf graf--p graf-after--li">
                            <strong class="markup--strong markup--p-strong">n = 2^{h-1} * 2–1<br />n = 2^{h-1} * 2¹ — 1<br />n =
                                2^{h-1+1}- 1<br />n = 2^{h} — 1</strong>
                        </p>
                        <p name="4cc3" id="4cc3" class="graf graf--p graf-after--p">
                            So that’s how we can go from h to n. What about the other
                            direction?
                        </p>
                        <p name="79be" id="79be" class="graf graf--p graf-after--p">
                            We need to bring the h down from the exponent.
                        </p>
                        <p name="998a" id="998a" class="graf graf--p graf-after--p">
                            That’s what logs are for!
                        </p>
                        <p name="1a08" id="1a08" class="graf graf--p graf-after--p">
                            First, some quick review.
                        </p>
                        <p name="a3d7" id="a3d7" class="graf graf--p graf-after--p">
                            &lt;==(log_{10} (100) )==&gt;
                        </p>
                        <p name="f95d" id="f95d" class="graf graf--p graf-after--p">
                            simply means,
                        </p>
                        <p name="7134" id="7134" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">
                            <strong class="markup--strong markup--p-strong">“What power must you raise 10 to in order to get
                                100?”</strong>.
                        </p>
                        <p name="af6d" id="af6d" class="graf graf--p graf-after--p">
                            Which is 2,
                        </p>
                        <p name="bd35" id="bd35" class="graf graf--p graf-after--p">
                            because .
                        </p>
                        <p name="c097" id="c097" class="graf graf--p graf-after--p">
                            &lt;==(10² = 100 )==&gt;
                        </p>
                        <h3 name="679d" id="679d" class="graf graf--h3 graf-after--p">
                            Graph Data Structure: Directed, Acyclic, etc
                        </h3>
                        <p name="8e1e" id="8e1e" class="graf graf--p graf-after--h3">
                            Graph =====
                        </p>
                        <figure name="7695" id="7695" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--GNq3q4mT--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/graph-md.png" />
                        </figure>
                        <h3 name="3fbb" id="3fbb" class="graf graf--h3 graf-after--figure">
                            Binary numbers
                        </h3>
                        <p name="96aa" id="96aa" class="graf graf--p graf-after--h3">
                            Let’s put those bits to use. Let’s store some stuff. Starting
                            with numbers.
                        </p>
                        <p name="3b41" id="3b41" class="graf graf--p graf-after--p">
                            The number system we usually use (the one you probably learned
                            in elementary school) is called
                            <strong class="markup--strong markup--p-strong">base 10</strong>, because each digit has
                            <em class="markup--em markup--p-em">ten</em> possible values (1,
                            2, 3, 4, 5, 6, 7, 8, 9, and 0).
                        </p>
                        <p name="2245" id="2245" class="graf graf--p graf-after--p">
                            But computers don’t have digits with ten possible values. They
                            have <em class="markup--em markup--p-em">bits</em> with
                            <em class="markup--em markup--p-em">two</em> possible values. So
                            they use
                            <strong class="markup--strong markup--p-strong">base 2</strong>
                            numbers.
                        </p>
                        <p name="4065" id="4065" class="graf graf--p graf-after--p">
                            Base 10 is also called
                            <strong class="markup--strong markup--p-strong">decimal</strong>. Base 2 is also called
                            <strong class="markup--strong markup--p-strong">binary</strong>.
                        </p>
                        <p name="b502" id="b502" class="graf graf--p graf-after--p">
                            To understand binary, let’s take a closer look at how decimal
                            numbers work. Take the number “101” in decimal:
                        </p>
                        <figure name="cc27" id="cc27" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--H335nhE3--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__binary_numbers_base_10_101.svg%3Fbust%3D209" alt="In base 10, the digits 101 represent 1 hundred, 0 tens, and 1 one." />
                        </figure>
                        <p name="94ed" id="94ed" class="graf graf--p graf-after--figure">
                            Notice we have two “1”s here, but they don’t
                            <em class="markup--em markup--p-em">mean</em> the same thing.
                            The leftmost “1”
                            <em class="markup--em markup--p-em">means</em> 100, and the
                            rightmost “1” <em class="markup--em markup--p-em">means</em> 1.
                            That’s because the leftmost “1” is in the hundreds place, while
                            the rightmost “1” is in the ones place. And the “0” between them
                            is in the tens place.
                        </p>
                        <figure name="10f4" id="10f4" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--LgJeI2gg--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__binary_numbers_base_10_digits.svg%3Fbust%3D209" alt="In base 10, the digits 101 represent 1 hundred, 0 tens, and 1 one." />
                        </figure>
                        <p name="2fd4" id="2fd4" class="graf graf--p graf-after--figure">
                            <strong class="markup--strong markup--p-strong">So this “101” in base 10 is telling us we have “1 hundred, 0
                                tens, and 1 one.”</strong>
                        </p>
                        <figure name="b21f" id="b21f" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--rMqfBD7Y--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__binary_numbers_base_10.svg%3Fbust%3D209" alt="In base 10, the digits 101 represent 1 hundred, 0 tens, and 1 one, which add to give the value one hundred and one." />
                        </figure>
                        <p name="54eb" id="54eb" class="graf graf--p graf-after--figure">
                            Notice how the
                            <em class="markup--em markup--p-em">places</em> in base 10 (ones
                            place, tens place, hundreds place, etc.) are
                            <em class="markup--em markup--p-em">sequential powers of 10</em>:
                        </p>
                        <ul class="postList">
                            <li name="e308" id="e308" class="graf graf--li graf-after--p">
                                10⁰=1 * 10¹=10 * 10²=100 * 10³=1000 * etc.
                            </li>
                        </ul>
                        <p name="c7f5" id="c7f5" class="graf graf--p graf-after--li">
                            <strong class="markup--strong markup--p-strong">The places in
                                <em class="markup--em markup--p-em">binary</em> (base 2) are
                                sequential powers of
                                <em class="markup--em markup--p-em">2</em>:</strong>
                        </p>
                        <ul class="postList">
                            <li name="965b" id="965b" class="graf graf--li graf-after--p">
                                2⁰=1 * 2¹=2 * 2²=4 * 2³=8 * etc.
                            </li>
                        </ul>
                        <p name="da7e" id="da7e" class="graf graf--p graf-after--li">
                            So let’s take that same “101” but this time let’s read it as a
                            <em class="markup--em markup--p-em">binary</em> number:
                        </p>
                        <figure name="d425" id="d425" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--blzs_KIB--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__binary_numbers_base_2_digits.svg%3Fbust%3D209" alt="In base 2, the digits 101 represent 1 four, 0 twos, and 1 one." />
                        </figure>
                        <p name="5dfc" id="5dfc" class="graf graf--p graf-after--figure">
                            Reading this from right to left: we have a 1 in the ones place,
                            a 0 in the twos place, and a 1 in the fours place. So our total
                            is 4 + 0 + 1 which is 5.
                        </p>
                        <figure name="05c0" id="05c0" class="graf graf--figure graf-after--p">
                            <img class="graf-image" data-external-src="https://res.cloudinary.com/practicaldev/image/fetch/s--gLFVOg82--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.interviewcake.com/images/svgs/cs_for_hackers__binary_numbers_base_2.svg%3Fbust%3D209" alt="In base 2, the digits 101 represent 1 four, 0 twos, and 1 one, which add to give the value five." />
                        </figure>
                        <p name="159e" id="159e" class="
                  graf graf--p graf--empty
                  graf-after--figure
                  graf--trailing
                ">
                            <br />
                        </p>
                    </div>
                </div>
            </section>
        </section>
        <footer>
            <p><a href="https://medium.com/p/f3904751cf0a">View original.</a></p>
            <p>
                Exported from <a href="https://medium.com">Medium</a> on August 10,
                2021.
            </p>
        </footer>
    </article>
</body>

</html>
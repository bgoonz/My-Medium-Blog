<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Exploring Time Complexity In JavaScript</title>
    <style>
        * {
            font-family: Georgia, Cambria, "Times New Roman", Times, serif;
        }

        html,
        body {
            margin: 0;
            padding: 0;
        }

        h1 {
            font-size: 50px;
            margin-bottom: 17px;
            color: #333;
        }

        h2 {
            font-size: 24px;
            line-height: 1.6;
            margin: 30px 0 0 0;
            margin-bottom: 18px;
            margin-top: 33px;
            color: #333;
        }

        h3 {
            font-size: 30px;
            margin: 10px 0 20px 0;
            color: #333;
        }

        header {
            width: 640px;
            margin: auto;
        }

        section {
            width: 640px;
            margin: auto;
        }

        section p {
            margin-bottom: 27px;
            font-size: 20px;
            line-height: 1.6;
            color: #333;
        }

        section img {
            max-width: 640px;
        }

        footer {
            padding: 0 20px;
            margin: 50px 0;
            text-align: center;
            font-size: 12px;
        }

        .aspectRatioPlaceholder {
            max-width: auto !important;
            max-height: auto !important;
        }

        .aspectRatioPlaceholder-fill {
            padding-bottom: 0 !important;
        }

        header,
        section[data-field=subtitle],
        section[data-field=description] {
            display: none;
        }
    </style>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bgoonz/GIT-CDN-FILES/mdn-article.css">
</head>

<body>
    <article class="h-entry">
        <header>
            <h1 class="p-name">Exploring Time Complexity In JavaScript</h1>
        </header>
        <section data-field="subtitle" class="p-summary">
            What is time complexity?
        </section>
        <section data-field="body" class="e-content">
            <section name="d03e" class="section section--body section--first">
                <div class="section-divider">
                    <hr class="section-divider">
                </div>
                <div class="section-content">
                    <div class="section-inner sectionLayout--insetColumn">
                        <h3 name="2f17" id="2f17" class="graf graf--h3 graf--leading graf--title">Exploring Time Complexity In JavaScript</h3>
                        <p name="f295" id="f295" class="graf graf--p graf--empty graf-after--h3"><br></p>
                        <p name="6a38" id="6a38" class="graf graf--p graf--empty graf-after--p"><br></p>
                        <figure name="db41" id="db41" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*KP9Vgq0F-GHrNsbE.gif" data-width="560" data-height="420" src="https://cdn-images-1.medium.com/max/800/0*KP9Vgq0F-GHrNsbE.gif"></figure>
                        <h3 name="1556" id="1556" class="graf graf--h3 graf-after--figure">What is time complexity?</h3>
                        <figure name="6301" id="6301" class="graf graf--figure graf--iframe graf-after--h3"><iframe src="https://codesandbox.io/embed/ggkhe" width="700" height="350" frameborder="0" scrolling="no"></iframe></figure>
                        <p name="1f83" id="1f83" class="graf graf--p graf--empty graf-after--figure"><br></p>
                        <p name="0b97" id="0b97" class="graf graf--p graf-after--p">To recap time complexity estimates how an algorithm performs regardless of the kind of machine it runs on. You can get the time complexity by ‚Äúcounting‚Äù the number of operations performed by your code. This time complexity is defined as a function of the input size <code class="markup--code markup--p-code">n</code> using Big-O notation. <code class="markup--code markup--p-code">n</code> indicates the input size, while O is the worst-case scenario growth rate function.</p>
                        <p name="b6df" id="b6df" class="graf graf--p graf-after--p">We use the Big-O notation to classify algorithms based on their running time or space (memory used) as the input grows. The <code class="markup--code markup--p-code">O</code> function is the growth rate in function of the input size <code class="markup--code markup--p-code">n</code>.</p>
                        <p name="fa93" id="fa93" class="graf graf--p graf-after--p">Here are the big O cheatsheet and examples that we will cover in this post before we dive in. Click on them to go to the implementation.¬†</p>
                        <figure name="3c84" id="3c84" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*OH7UGBalhUnQ0jIB28JHvQ.png" data-width="617" data-height="386" src="https://cdn-images-1.medium.com/max/800/1*OH7UGBalhUnQ0jIB28JHvQ.png"></figure>
                        <p name="0d49" id="0d49" class="graf graf--p graf--empty graf-after--figure graf--trailing"><br></p>
                    </div>
                </div>
            </section>
            <section name="545f" class="section section--body">
                <div class="section-divider">
                    <hr class="section-divider">
                </div>
                <div class="section-content">
                    <div class="section-inner sectionLayout--insetColumn">
                        <p name="c40f" id="c40f" class="graf graf--p graf--empty graf--leading"><br></p>
                    </div>
                    <div class="section-inner sectionLayout--outsetColumn">
                        <figure name="0736" id="0736" class="graf graf--figure graf--iframe graf--layoutOutsetCenter graf-after--p graf--trailing"><iframe src="https://replit.com/@bgoonz/data-structures?lite=true&amp;amp%3Breferrer=https%3A%2F%2Fbryanguner.medium.com&amp;lite=true" width="1192" height="894" frameborder="0" scrolling="no"></iframe></figure>
                    </div>
                </div>
            </section>
            <section name="c48a" class="section section--body section--last">
                <div class="section-divider">
                    <hr class="section-divider">
                </div>
                <div class="section-content">
                    <div class="section-inner sectionLayout--insetColumn">
                        <h3 name="136f" id="136f" class="graf graf--h3 graf--leading">O(1)‚Ää‚Äî‚ÄäConstant¬†time</h3>
                        <p name="1a95" id="1a95" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">O(1)</code> describes algorithms that take the same amount of time to compute regardless of the input size.</p>
                        <p name="29c1" id="29c1" class="graf graf--p graf-after--p">For instance, if a function takes the same time to process ten elements and 1 million items, then we say that it has a constant growth rate or <code class="markup--code markup--p-code">O(1)</code>. Let‚Äôs see some cases.</p>
                        <p name="f024" id="f024" class="graf graf--p graf-after--p">Examples of constant runtime algorithms:</p>
                        <ul class="postList">
                            <li name="4c0c" id="4c0c" class="graf graf--li graf-after--p">Find if a number is even or odd.</li>
                            <li name="8b5b" id="8b5b" class="graf graf--li graf-after--li">Check if an item on an array is null.</li>
                            <li name="136b" id="136b" class="graf graf--li graf-after--li">Print the first element from a list.</li>
                            <li name="1406" id="1406" class="graf graf--li graf-after--li">Find a value on a map.</li>
                        </ul>
                        <h3 name="852b" id="852b" class="graf graf--h3 graf-after--li">Odd or¬†Even</h3>
                        <p name="a987" id="a987" class="graf graf--p graf-after--h3">Find if a number is odd or even.</p>
                        <pre name="3634" id="3634" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">function isEvenOrOdd(n) {<br>  return n % 2 ? &#39;Odd&#39; : &#39;Even&#39;;<br>}</code></pre>
                        <pre name="4ee2" id="4ee2" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">console.log(isEvenOrOdd(10)); // =&gt; Even<br>console.log(isEvenOrOdd(10001)); // =&gt; Odd</code></pre>
                        <p name="90aa" id="90aa" class="graf graf--p graf--empty graf-after--pre"><br></p>
                        <blockquote name="276a" id="276a" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">Do not be fooled by one-liners. They don‚Äôt always translate to constant times. You have to be aware of how they are implemented.</em></blockquote>
                        <p name="615a" id="615a" class="graf graf--p graf-after--blockquote">If you have a method like <code class="markup--code markup--p-code">Array.sort()</code> or any other array or object method, you have to look into the under-the-hood implementation to determine its running time.</p>
                        <p name="69f7" id="69f7" class="graf graf--p graf-after--p">Primitive operations like sum, multiplication, subtraction, division, modulo, bit shift, etc., have a constant runtime. Did you expect that? Let‚Äôs go into detail about why they are constant time. If you use the schoolbook long multiplication algorithm, it would take <code class="markup--code markup--p-code">O(n2)</code> to multiply two numbers. However, most programming languages limit numbers to max value (e.g. in JS: <code class="markup--code markup--p-code">Number.MAX_VALUE</code> is <code class="markup--code markup--p-code">1.7976931348623157e+308</code>). So, you cannot operate numbers that yield a result greater than the <code class="markup--code markup--p-code">MAX_VALUE</code>. So, primitive operations are bound to be completed on a fixed amount of instructions <code class="markup--code markup--p-code">O(1)</code> or throw overflow errors (in JS, <code class="markup--code markup--p-code">Infinity</code> keyword).</p>
                        <p name="70df" id="70df" class="graf graf--p graf-after--p">This example was easy. Let‚Äôs do another one.</p>
                        <h3 name="6cc9" id="6cc9" class="graf graf--h3 graf-after--p">Look-up table</h3>
                        <p name="0b27" id="0b27" class="graf graf--p graf-after--h3">Given a string, find its word frequency data.</p>
                        <pre name="1a00" id="1a00" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">const dictionary = {the: 22038615, be: 12545825, and: 10741073, of: 10343885, a: 10144200, in: 6996437, to: 6332195 /* ... */};</code></pre>
                        <pre name="4fe6" id="4fe6" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">function getWordFrequency(dictionary, word) {<br>return dictionary[word];<br>}</code></pre>
                        <pre name="f24c" id="f24c" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">console.log(getWordFrequency(dictionary, &#39;the&#39;));<br>console.log(getWordFrequency(dictionary, &#39;in&#39;));</code></pre>
                        <p name="8a95" id="8a95" class="graf graf--p graf-after--pre">Again, we can be sure that even if the dictionary has 10 or 1 million words, it would still execute line 4 once to find the word. However, if we decided to store the dictionary as an array rather than a hash map, it would be a different story. In the next section, we will explore what‚Äôs the running time to find an item in an array.</p>
                        <blockquote name="c384" id="c384" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">Only a hash table with a perfect </em>hash function<em class="markup--em markup--blockquote-em"> will have a worst-case runtime of </em>O(1)<em class="markup--em markup--blockquote-em">. The ideal hash function is not practical, so some collisions and workarounds lead to a worst-case runtime of </em>O(n)<em class="markup--em markup--blockquote-em">. Still, on </em>average<em class="markup--em markup--blockquote-em">, the lookup time is </em>O(1)<em class="markup--em markup--blockquote-em">.</em></blockquote>
                        <h3 name="c5cc" id="c5cc" class="graf graf--h3 graf-after--blockquote">O(n)‚Ää‚Äî‚ÄäLinear¬†time</h3>
                        <p name="794d" id="794d" class="graf graf--p graf-after--h3">Linear running time algorithms are widespread. These algorithms imply that the program visits every element from the input.</p>
                        <p name="7a0f" id="7a0f" class="graf graf--p graf-after--p">Linear time complexity <code class="markup--code markup--p-code"><em class="markup--em markup--p-em">O(n)</em></code> means that the algorithms take proportionally longer to complete as the input grows.</p>
                        <p name="8ca3" id="8ca3" class="graf graf--p graf-after--p">Examples of linear time algorithms:</p>
                        <ul class="postList">
                            <li name="0587" id="0587" class="graf graf--li graf-after--p">Get the max/min value in an array.</li>
                            <li name="ad59" id="ad59" class="graf graf--li graf-after--li">Find a given element in a collection.</li>
                            <li name="d49a" id="d49a" class="graf graf--li graf-after--li">Print all the values in a list.</li>
                        </ul>
                        <h3 name="8ddd" id="8ddd" class="graf graf--h3 graf-after--li">The largest item on an unsorted¬†array</h3>
                        <p name="f2e7" id="f2e7" class="graf graf--p graf-after--h3">Let‚Äôs say you want to find the maximum value from an unsorted array.</p>
                        <pre name="a35d" id="a35d" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">function findMax(n) {<br>  let max;<br>  let counter = 0;</code></pre>
                        <pre name="766d" id="766d" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">for (let i = 0; i &lt; n.length; i++) {<br>counter++;<br>if(max === undefined || max &lt; n[i]) {<br>max = n[i];<br>}<br>}</code></pre>
                        <pre name="4f56" id="4f56" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">console.log(n: ${n.length}, counter: ${counter});<br>return max;<br>}</code></pre>
                        <p name="3425" id="3425" class="graf graf--p graf-after--pre">How many operations will the <code class="markup--code markup--p-code">findMax</code> function do?</p>
                        <p name="5584" id="5584" class="graf graf--p graf-after--p">Well, it checks every element from <code class="markup--code markup--p-code">n</code>. If the current item is more significant than <code class="markup--code markup--p-code">max</code> it will do an assignment.</p>
                        <p name="6a53" id="6a53" class="graf graf--p graf-after--p">Notice that we added a counter to count how many times the inner block is executed.</p>
                        <p name="3083" id="3083" class="graf graf--p graf-after--p">If you get the time complexity, it would be something like this:</p>
                        <ul class="postList">
                            <li name="5828" id="5828" class="graf graf--li graf-after--p">Line 2‚Äì3: 2 operations</li>
                            <li name="1a0e" id="1a0e" class="graf graf--li graf-after--li">Line 4: a loop of size n</li>
                            <li name="ab37" id="ab37" class="graf graf--li graf-after--li">Line 6‚Äì8: 3 operations inside the for-loop.</li>
                        </ul>
                        <p name="d377" id="d377" class="graf graf--p graf-after--li">So, this gets us <code class="markup--code markup--p-code">3(n) + 2</code>.</p>
                        <p name="f359" id="f359" class="graf graf--p graf-after--p">Applying the Big O notation that we learn in the <a href="https://master--bgoonz-blog.netlify.app/blog/2018/04/04/how-you-can-change-the-world-learning-data-structures-algorithms-free-online-course-tutorial/#Asymptotic-analysis" data-href="https://master--bgoonz-blog.netlify.app/blog/2018/04/04/how-you-can-change-the-world-learning-data-structures-algorithms-free-online-course-tutorial/#Asymptotic-analysis" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">previous post</a>, we only need the biggest order term, thus <code class="markup--code markup--p-code">O(n)</code>.</p>
                        <p name="9230" id="9230" class="graf graf--p graf-after--p">We can verify this using our <code class="markup--code markup--p-code">counter</code>. If <code class="markup--code markup--p-code">n</code> has 3 elements:</p>
                        <pre name="d42f" id="d42f" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">findMax([3, 1, 2]);<br>// n: 3, counter: 3</code></pre>
                        <p name="2464" id="2464" class="graf graf--p graf-after--pre">or if <code class="markup--code markup--p-code">n</code> has 9 elements:</p>
                        <pre name="8006" id="8006" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">findMax([4,5,6,1,9,2,8,3,7])<br>// n: 9, counter: 9</code></pre>
                        <p name="fd4b" id="fd4b" class="graf graf--p graf-after--pre">Now imagine that you have an array of one million items. Do you think it will take the same time? Of course not. It will take longer to the size of the input. If we plot <code class="markup--code markup--p-code">n</code> and <code class="markup--code markup--p-code">findMax</code> running time, we will have a linear function graph.</p>
                        <figure name="ceed" id="ceed" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*kFuxx3O5jSwHx5Mo.jpg" data-width="513" data-height="354" src="https://cdn-images-1.medium.com/max/800/0*kFuxx3O5jSwHx5Mo.jpg"></figure>
                        <h3 name="e052" id="e052" class="graf graf--h3 graf-after--figure">O(n¬≤)‚Ää‚Äî‚ÄäQuadratic time</h3>
                        <p name="898f" id="898f" class="graf graf--p graf-after--h3">A function with a quadratic time complexity has a growth rate of n2. If the input is size 2, it will do four operations. If the input is size 8, it will take 64, and so on.</p>
                        <p name="3a55" id="3a55" class="graf graf--p graf-after--p">Here are some examples of quadratic algorithms:</p>
                        <ul class="postList">
                            <li name="60ce" id="60ce" class="graf graf--li graf-after--p">Check if a collection has duplicated values.</li>
                            <li name="8d12" id="8d12" class="graf graf--li graf-after--li">Sorting items in a collection using bubble sort, insertion sort, or selection sort.</li>
                            <li name="d80d" id="d80d" class="graf graf--li graf-after--li">Find all possible ordered pairs in an array.</li>
                        </ul>
                        <p name="cd8b" id="cd8b" class="graf graf--p graf-after--li">Let‚Äôs implement the first two.</p>
                        <h3 name="bdc1" id="bdc1" class="graf graf--h3 graf-after--p">Has duplicates</h3>
                        <p name="52b6" id="52b6" class="graf graf--p graf-after--h3">You want to find duplicate words in an array. A na√Øve solution will be the following:</p>
                        <pre name="1d31" id="1d31" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">function hasDuplicates(n) {<br>  const duplicates = [];<br>  let counter = 0; // debug</code></pre>
                        <pre name="fd83" id="fd83" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">for (let outter = 0; outter &lt; n.length; outter++) {<br>for (let inner = 0; inner &lt; n.length; inner++) {<br>counter++; // debug</code></pre>
                        <pre name="8c3d" id="8c3d" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <pre name="8398" id="8398" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <pre name="a2ce" id="a2ce" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">if(outter === inner) continue;</code></pre>
                        <pre name="d302" id="d302" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  if(n[outter] === n[inner]) {<br>    return true;<br>  }<br>}<br>}</code></pre>
                        <pre name="0034" id="0034" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">console.log(n: ${n.length}, counter: ${counter}); // debug<br>return false;<br>}</code></pre>
                        <p name="3dae" id="3dae" class="graf graf--p graf-after--pre">Time complexity analysis:</p>
                        <ul class="postList">
                            <li name="d483" id="d483" class="graf graf--li graf-after--p">Line 2‚Äì3: 2 operations</li>
                            <li name="93eb" id="93eb" class="graf graf--li graf-after--li">Line 5‚Äì6: double-loop of size n, so <code class="markup--code markup--li-code">n^2</code>.</li>
                            <li name="a15e" id="a15e" class="graf graf--li graf-after--li">Line 7‚Äì13: has ~3 operations inside the double-loop</li>
                        </ul>
                        <p name="f8a1" id="f8a1" class="graf graf--p graf-after--li">We get <code class="markup--code markup--p-code">3n^2 + 2</code>.</p>
                        <p name="54f2" id="54f2" class="graf graf--p graf-after--p">When we have an asymptotic analysis, we drop all constants and leave the most critical term: <code class="markup--code markup--p-code">n^2</code>. So, in the big O notation, it would be <code class="markup--code markup--p-code">O(n^2)</code>.</p>
                        <p name="44df" id="44df" class="graf graf--p graf-after--p">We are using a counter variable to help us verify. The <code class="markup--code markup--p-code">hasDuplicates</code> function has two loops. If we have an input of 4 words, it will execute the inner block 16 times. If we have 9, it will perform counter 81 times and so forth.</p>
                        <pre name="b653" id="b653" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">hasDuplicates([1,2,3,4]);<br>// n: 4, counter: 16</code></pre>
                        <p name="64c1" id="64c1" class="graf graf--p graf-after--pre">and with n size 9:</p>
                        <pre name="ad67" id="ad67" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">hasDuplicates([1,2,3,4,5,6,7,8,9]);<br>// n: 9, counter: 81</code></pre>
                        <p name="8be5" id="8be5" class="graf graf--p graf--empty graf-after--pre"><br></p>
                        <h3 name="ea6b" id="ea6b" class="graf graf--h3 graf-after--p">Bubble sort</h3>
                        <p name="7f6b" id="7f6b" class="graf graf--p graf-after--h3">We want to sort the elements in an array. One way to do this is using bubble sort as follows:</p>
                        <pre name="8043" id="8043" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">function sort(n) {<br>  for (let outer = 0; outer &lt; n.length; outer++) {<br>    let outerElement = n[outer];</code></pre>
                        <pre name="7f41" id="7f41" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">for (let inner = outer + 1; inner &amp;lt; n.length; inner++) {<br>  let innerElement = n[inner];</code></pre>
                        <pre name="6e9d" id="6e9d" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  if(outerElement &amp;gt; innerElement) {<br>    // swap<br>    n[outer] = innerElement;<br>    n[inner] = outerElement;<br>    // update references<br>    outerElement = n[outer];<br>    innerElement = n[inner];<br>  }<br>}</code></pre>
                        <pre name="22d8" id="22d8" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">}<br>return n;<br>}</code></pre>
                        <p name="0213" id="0213" class="graf graf--p graf-after--pre">You might also notice that for a very big <code class="markup--code markup--p-code">n</code>, the time it takes to solve the problem increases a lot. Can you spot the relationship between nested loops and the running time? When a function has a single loop, it usually translates into a running time complexity of O(n). Now, this function has 2 nested loops and quadratic running time: O(n2).</p>
                        <h3 name="155f" id="155f" class="graf graf--h3 graf-after--p">O(n^c)‚Ää‚Äî‚ÄäPolynomial time</h3>
                        <p name="ca6f" id="ca6f" class="graf graf--p graf-after--h3">Polynomial running is represented as O(nc), when <code class="markup--code markup--p-code">c &gt; 1</code>. As you already saw, two inner loops almost translate to O(n2) since it has to go through the array twice in most cases. Are three nested loops cubic? If each one visit all elements, then yes!</p>
                        <p name="e3c0" id="e3c0" class="graf graf--p graf-after--p">Usually, we want to stay away from polynomial running times (quadratic, cubic, nc, etc.) since they take longer to compute as the input grows fast. However, they are not the worst.</p>
                        <h3 name="c93d" id="c93d" class="graf graf--h3 graf-after--p">Triple nested¬†loops</h3>
                        <p name="5fa5" id="5fa5" class="graf graf--p graf-after--h3">Let‚Äôs say you want to find the solutions for a multi-variable equation that looks like this:</p>
                        <blockquote name="3c35" id="3c35" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">3x + 9y + 8z = 79</em></blockquote>
                        <blockquote name="01be" id="01be" class="graf graf--blockquote graf--empty graf-after--blockquote"><br></blockquote>
                        <p name="2296" id="2296" class="graf graf--p graf-after--blockquote">This na√Øve program will give you all the solutions that satisfy the equation where <code class="markup--code markup--p-code">x</code>, <code class="markup--code markup--p-code">y</code>, and <code class="markup--code markup--p-code">z</code> &lt; <code class="markup--code markup--p-code">n</code>.</p>
                        <pre name="d887" id="d887" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">function findXYZ(n) {<br>  const solutions = [];</code></pre>
                        <pre name="0ccc" id="0ccc" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">for(let x = 0; x &lt; n; x++) {<br>for(let y = 0; y &lt; n; y++) {<br>for(let z = 0; z &lt; n; z++) {<br>if( 3<em class="markup--em markup--pre-em">x + 9</em>y + 8*z === 79 ) {<br>solutions.push({x, y, z});<br>}<br>}<br>}<br>}</code></pre>
                        <pre name="0475" id="0475" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <pre name="29ac" id="29ac" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <pre name="3781" id="3781" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">return solutions;<br>}</code></pre>
                        <pre name="dce2" id="dce2" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <pre name="9f73" id="9f73" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <pre name="188f" id="188f" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">console.log(findXYZ(10)); // =&gt; [{x: 0, y: 7, z: 2}, ...]</code></pre>
                        <pre name="5b94" id="5b94" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <pre name="2493" id="2493" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <p name="84e8" id="84e8" class="graf graf--p graf-after--pre">This algorithm has a cubic running time: <code class="markup--code markup--p-code">O(n^3)</code>.</p>
                        <p name="6f0d" id="6f0d" class="graf graf--p graf-after--p">** Note:** We could do a more efficient solution to solve multi-variable equations, but this works to show an example of a cubic runtime.</p>
                        <h3 name="af98" id="af98" class="graf graf--h3 graf-after--p">O(log n)‚Ää‚Äî‚ÄäLogarithmic time</h3>
                        <p name="bfd3" id="bfd3" class="graf graf--p graf-after--h3">Logarithmic time complexities usually apply to algorithms that divide problems in half every time. For instance, let‚Äôs say that we want to look for a book in a dictionary. As you know, this book has every word sorted alphabetically. If you are looking for a word, then there are at least two ways to do it:</p>
                        <p name="b814" id="b814" class="graf graf--p graf-after--p">Algorithm A:</p>
                        <ol class="postList">
                            <li name="4740" id="4740" class="graf graf--li graf-after--p">Start on the first page of the book and go word by word until you find what you are looking for.</li>
                        </ol>
                        <p name="0c4b" id="0c4b" class="graf graf--p graf-after--li">Algorithm B:</p>
                        <ol class="postList">
                            <li name="d6d7" id="d6d7" class="graf graf--li graf-after--p">Open the book in the middle and check the first word on it.</li>
                            <li name="9c30" id="9c30" class="graf graf--li graf-after--li">If the word you are looking for is alphabetically more significant, then look to the right. Otherwise, look in the left half.</li>
                            <li name="5559" id="5559" class="graf graf--li graf-after--li">Divide the remainder in half again, and repeat step #2 until you find the word you are looking for.</li>
                        </ol>
                        <p name="5bec" id="5bec" class="graf graf--p graf-after--li">Which one is faster? The first algorithms go word by word <em class="markup--em markup--p-em">O(n)</em>, while the algorithm B split the problem in half on each iteration <em class="markup--em markup--p-em">O(log n)</em>. This 2nd algorithm is a binary search.</p>
                        <h3 name="e26a" id="e26a" class="graf graf--h3 graf-after--p">Binary search</h3>
                        <p name="28e2" id="28e2" class="graf graf--p graf-after--h3">Find the index of an element in a sorted array.</p>
                        <p name="88ae" id="88ae" class="graf graf--p graf-after--p">If we implement (Algorithm A) going through all the elements in an array, it will take a running time of <code class="markup--code markup--p-code">O(n)</code>. Can we do better? We can try using the fact that the collection is already sorted. Later, we can divide it in half as we look for the element in question.</p>
                        <pre name="fb6f" id="fb6f" class="graf graf--pre graf--empty graf-after--p"><br></pre>
                        <pre name="38d3" id="38d3" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">function indexOf(array, element, offset = 0) {<br>  // split array in half<br>  const half = parseInt(array.length / 2);<br>  const current = array[half];</code></pre>
                        <pre name="920e" id="920e" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">if(current === element) {<br>return offset + half;<br>} else if(element &gt; current) {<br>const right = array.slice(half);<br>return indexOf(right, element, offset + half);<br>} else {<br>const left = array.slice(0, half)<br>return indexOf(left, element, offset);<br>}<br>}</code></pre>
                        <pre name="2631" id="2631" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <pre name="383e" id="383e" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <pre name="27f2" id="27f2" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// Usage example with a list of names in ascending order:<br>const directory = [&quot;Adrian&quot;, &quot;Bella&quot;, &quot;Charlotte&quot;, &quot;Daniel&quot;, &quot;Emma&quot;, &quot;Hanna&quot;, &quot;Isabella&quot;, &quot;Jayden&quot;, &quot;Kaylee&quot;, &quot;Luke&quot;, &quot;Mia&quot;, &quot;Nora&quot;, &quot;Olivia&quot;, &quot;Paisley&quot;, &quot;Riley&quot;, &quot;Thomas&quot;, &quot;Wyatt&quot;, &quot;Xander&quot;, &quot;Zoe&quot;];<br>console.log(indexOf(directory, &#39;Hanna&#39;)); // =&gt; 5<br>console.log(indexOf(directory, &#39;Adrian&#39;)); // =&gt; 0<br>console.log(indexOf(directory, &#39;Zoe&#39;)); // =&gt; 18</code></pre>
                        <pre name="6c06" id="6c06" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <pre name="fa7b" id="fa7b" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <p name="89d8" id="89d8" class="graf graf--p graf-after--pre">Calculating the time complexity of <code class="markup--code markup--p-code">indexOf</code> is not as straightforward as the previous examples. This function is recursive.</p>
                        <p name="5242" id="5242" class="graf graf--p graf-after--p">There are several ways to analyze recursive algorithms. For simplicity, we are going to use the <code class="markup--code markup--p-code">Master Method</code>.</p>
                        <h3 name="e8ce" id="e8ce" class="graf graf--h3 graf-after--p">Master Method for recursive algorithms</h3>
                        <p name="85e7" id="85e7" class="graf graf--p graf-after--h3">Finding the runtime of recursive algorithms is not as easy as counting the operations. This method helps us to determine the runtime of recursive algorithms. We are going to explain this solution using the <code class="markup--code markup--p-code">indexOf</code> function as an illustration.</p>
                        <p name="6ba0" id="6ba0" class="graf graf--p graf-after--p">When analyzing recursive algorithms, we care about these three things:</p>
                        <ul class="postList">
                            <li name="d11a" id="d11a" class="graf graf--li graf-after--p">The runtime of the work done outside the recursion (line 3‚Äì4): <code class="markup--code markup--li-code">O(1)</code></li>
                            <li name="4013" id="4013" class="graf graf--li graf-after--li">How many recursive calls the problem is divided (line 11 or 14): <code class="markup--code markup--li-code">1</code> recursive call. Notice only one or the other will happen, never both.</li>
                            <li name="e225" id="e225" class="graf graf--li graf-after--li">How much <code class="markup--code markup--li-code">n</code> is reduced on each recursive call (line 10 or 13): <code class="markup--code markup--li-code">1/2</code>. Every recursive call cuts <code class="markup--code markup--li-code">n</code> in half.</li>
                        </ul>
                        <ol class="postList">
                            <li name="4eaa" id="4eaa" class="graf graf--li graf-after--li">The Master Method formula is the following:</li>
                        </ol>
                        <blockquote name="418e" id="418e" class="graf graf--blockquote graf-after--li"><em class="markup--em markup--blockquote-em">T(n) = a T(n/b) + f(n)</em></blockquote>
                        <blockquote name="7019" id="7019" class="graf graf--blockquote graf--empty graf-after--blockquote"><br></blockquote>
                        <p name="d74d" id="d74d" class="graf graf--p graf-after--blockquote">where:</p>
                        <ul class="postList">
                            <li name="945a" id="945a" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">T</code>: time complexity function in terms of the input size <code class="markup--code markup--li-code">n</code>.</li>
                            <li name="ee35" id="ee35" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">n</code>: the size of the input. duh?¬†:)</li>
                            <li name="1ade" id="1ade" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">a</code>: the number of sub-problems. For our case, we only split the problem into one subproblem. So, <code class="markup--code markup--li-code">a=1</code>.</li>
                            <li name="889d" id="889d" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">b</code>: the factor by which <code class="markup--code markup--li-code">n</code> is reduced. For our example, we divide <code class="markup--code markup--li-code">n</code> in half each time. Thus, <code class="markup--code markup--li-code">b=2</code>.</li>
                            <li name="cdb5" id="cdb5" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">f(n)</code>: the running time outside the recursion. Since dividing by 2 is constant time, we have <code class="markup--code markup--li-code">f(n) = O(1)</code>.</li>
                        </ul>
                        <ol class="postList">
                            <li name="9757" id="9757" class="graf graf--li graf-after--li">Once we know the values of <code class="markup--code markup--li-code">a</code>, <code class="markup--code markup--li-code">b</code> and <code class="markup--code markup--li-code">f(n)</code>. We can determine the runtime of the recursion using this formula:</li>
                        </ol>
                        <blockquote name="d814" id="d814" class="graf graf--blockquote graf-after--li"><em class="markup--em markup--blockquote-em">nlogba</em></blockquote>
                        <blockquote name="2e9b" id="2e9b" class="graf graf--blockquote graf--empty graf-after--blockquote"><br></blockquote>
                        <p name="dba2" id="dba2" class="graf graf--p graf-after--blockquote">This value will help us to find which master method case we are solving.</p>
                        <p name="c294" id="c294" class="graf graf--p graf-after--p">For binary search, we have:</p>
                        <p name="dc4d" id="dc4d" class="graf graf--p graf-after--p">nlogba = nlog21 = n0 = 1</p>
                        <ol class="postList">
                            <li name="7e54" id="7e54" class="graf graf--li graf-after--p">Finally, we compare the recursion runtime from step 2) and the runtime <code class="markup--code markup--li-code">f(n)</code> from step 1). Based on that, we have the following cases:</li>
                        </ol>
                        <p name="b13a" id="b13a" class="graf graf--p graf-after--li"><em class="markup--em markup--p-em">Case 1</em>: Most of the work done in the recursion.</p>
                        <p name="3597" id="3597" class="graf graf--p graf-after--p">If <code class="markup--code markup--p-code">nlogba</code> &gt; <code class="markup--code markup--p-code">f(n)</code>,</p>
                        <p name="9e0a" id="9e0a" class="graf graf--p graf-after--p">then runtime is:</p>
                        <blockquote name="2d6f" id="2d6f" class="graf graf--blockquote graf-after--p">O(nlogba)</blockquote>
                        <blockquote name="e747" id="e747" class="graf graf--blockquote graf--empty graf-after--blockquote"><br></blockquote>
                        <p name="a28c" id="a28c" class="graf graf--p graf-after--blockquote"><em class="markup--em markup--p-em">Case 2</em>: The runtime of the work done in the recursion and outside is the same</p>
                        <p name="6d6a" id="6d6a" class="graf graf--p graf-after--p">If <code class="markup--code markup--p-code">nlogba</code> === <code class="markup--code markup--p-code">f(n)</code>,</p>
                        <p name="2c48" id="2c48" class="graf graf--p graf-after--p">then runtime is:</p>
                        <blockquote name="d257" id="d257" class="graf graf--blockquote graf-after--p">O(nlogba log(n))</blockquote>
                        <blockquote name="6019" id="6019" class="graf graf--blockquote graf--empty graf-after--blockquote"><br></blockquote>
                        <p name="d995" id="d995" class="graf graf--p graf-after--blockquote"><em class="markup--em markup--p-em">Case 3</em>: Most of the work is done outside the recursion</p>
                        <p name="4301" id="4301" class="graf graf--p graf-after--p">If <code class="markup--code markup--p-code">nlogba</code> &lt; <code class="markup--code markup--p-code">f(n)</code>,</p>
                        <p name="bee1" id="bee1" class="graf graf--p graf-after--p">then runtime is:</p>
                        <blockquote name="115f" id="115f" class="graf graf--blockquote graf-after--p">O(f(n))</blockquote>
                        <blockquote name="a3d9" id="a3d9" class="graf graf--blockquote graf--empty graf-after--blockquote"><br></blockquote>
                        <p name="c8e6" id="c8e6" class="graf graf--p graf-after--blockquote">Now, let‚Äôs combine everything we learned here to get the running time of our binary search function <code class="markup--code markup--p-code">indexOf</code>.</p>
                        <h3 name="9322" id="9322" class="graf graf--h3 graf-after--p">Master Method for Binary¬†Search</h3>
                        <p name="3c8d" id="3c8d" class="graf graf--p graf-after--h3">The binary search algorithm slit <code class="markup--code markup--p-code">n</code> in half until a solution is found or the array is exhausted. So, using the Master Method:</p>
                        <blockquote name="ae04" id="ae04" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">T(n) = a T(n/b) + f(n)</em></blockquote>
                        <blockquote name="24ae" id="24ae" class="graf graf--blockquote graf--empty graf-after--blockquote"><br></blockquote>
                        <ol class="postList">
                            <li name="3fbf" id="3fbf" class="graf graf--li graf-after--blockquote">Find <code class="markup--code markup--li-code">a</code>, <code class="markup--code markup--li-code">b</code> and <code class="markup--code markup--li-code">f(n)</code> and replace it in the formula:</li>
                        </ol>
                        <ul class="postList">
                            <li name="63df" id="63df" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">a</code>: the number of sub-problems. For our example, we only split the problem into another subproblem. So <code class="markup--code markup--li-code">a=1</code>.</li>
                            <li name="1078" id="1078" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">b</code>: the factor by which <code class="markup--code markup--li-code">n</code> is reduced. For our case, we divide <code class="markup--code markup--li-code">n</code> in half each time. Thus, <code class="markup--code markup--li-code">b=2</code>.</li>
                            <li name="5469" id="5469" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">f(n)</code>: the running time outside the recursion: <code class="markup--code markup--li-code">O(1)</code>.</li>
                        </ul>
                        <p name="f392" id="f392" class="graf graf--p graf-after--li">Thus,</p>
                        <blockquote name="9e1b" id="9e1b" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">T(n) = T(n/2) + O(1)</em></blockquote>
                        <blockquote name="7a7a" id="7a7a" class="graf graf--blockquote graf--empty graf-after--blockquote"><br></blockquote>
                        <ol class="postList">
                            <li name="9f88" id="9f88" class="graf graf--li graf-after--blockquote">Compare the runtime executed inside and outside the recursion:</li>
                        </ol>
                        <ul class="postList">
                            <li name="0bd8" id="0bd8" class="graf graf--li graf-after--li">Runtime of the work done outside the recursion: <code class="markup--code markup--li-code">f(n)</code>. E.g. <code class="markup--code markup--li-code">O(1)</code>.</li>
                            <li name="1b39" id="1b39" class="graf graf--li graf-after--li">Runtime of work done inside the recursion given by this formula <code class="markup--code markup--li-code">nlogba</code>. E.g. O(<code class="markup--code markup--li-code">nlog21</code>) = O(<code class="markup--code markup--li-code">n0</code>) = <code class="markup--code markup--li-code">O(1)</code>.</li>
                        </ul>
                        <ol class="postList">
                            <li name="7bb7" id="7bb7" class="graf graf--li graf-after--li">Finally, getting the runtime. Based on the comparison of the expressions from the previous steps, find the case it matches.</li>
                        </ol>
                        <p name="d482" id="d482" class="graf graf--p graf-after--li">As we saw in the previous step, the work outside and inside the recursion has the same runtime, so we are in case 2.</p>
                        <blockquote name="3eaf" id="3eaf" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">O(nlogba log(n))</em></blockquote>
                        <blockquote name="4b37" id="4b37" class="graf graf--blockquote graf--empty graf-after--blockquote"><br></blockquote>
                        <p name="68c9" id="68c9" class="graf graf--p graf-after--blockquote">Making the substitution, we get:</p>
                        <p name="b390" id="b390" class="graf graf--p graf-after--p">O(nlog21 log(n))</p>
                        <p name="b327" id="b327" class="graf graf--p graf-after--p">O(n0 log(n))</p>
                        <p name="63a4" id="63a4" class="graf graf--p graf-after--p">O(log(n)) üëà this is the running time of a binary search</p>
                        <h3 name="505e" id="505e" class="graf graf--h3 graf-after--p">O(n log n)‚Ää‚Äî‚ÄäLinearithmic</h3>
                        <p name="4520" id="4520" class="graf graf--p graf-after--h3">Linearithmic time complexity it‚Äôs slightly slower than a linear algorithm. However, it‚Äôs still much better than a quadratic algorithm (you will see a graph at the very end of the post).</p>
                        <p name="39f4" id="39f4" class="graf graf--p graf-after--p">Examples of Linearithmic algorithms:</p>
                        <ul class="postList">
                            <li name="5ae7" id="5ae7" class="graf graf--li graf-after--p">Efficient sorting algorithms like merge sort, quicksort, and others.</li>
                        </ul>
                        <h3 name="f808" id="f808" class="graf graf--h3 graf-after--li">Mergesort</h3>
                        <p name="b999" id="b999" class="graf graf--p graf-after--h3">What‚Äôs the best way to sort an array? Before, we proposed a solution using bubble sort that has a time complexity of O(n2). Can we do better?</p>
                        <p name="9c1d" id="9c1d" class="graf graf--p graf-after--p">We can use an algorithm called <code class="markup--code markup--p-code">mergesort</code> to improve it. This is how mergesort works:</p>
                        <ol class="postList">
                            <li name="727b" id="727b" class="graf graf--li graf-after--p">We are going to divide the array recursively until the elements are two or less.</li>
                            <li name="5291" id="5291" class="graf graf--li graf-after--li">We know how to sort two items, so we sort them iteratively (base case).</li>
                            <li name="1eb8" id="1eb8" class="graf graf--li graf-after--li">The final step is merging: we merge in taking one by one from each array such that they are in ascending order.</li>
                        </ol>
                        <p name="315b" id="315b" class="graf graf--p graf-after--li">Here‚Äôs the code for merge sort:</p>
                        <pre name="06e9" id="06e9" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">/**<br> * Sort array in asc order using merge-sort<br> * @example<br> *    sort([3, 2, 1]) =&gt; [1, 2, 3]<br> *    sort([3]) =&gt; [3]<br> *    sort([3, 2]) =&gt; [2, 3]<br> * @param {array} array<br> */<br>function sort(array = []) {<br>  const size = array.length;<br>  // base case<br>  if (size &lt; 2) {<br>    return array;<br>  }<br>  if (size === 2) {<br>    return array[0] &gt; array[1] ? [array[1], array[0]] : array;<br>  }<br>  // slit and merge<br>  const mid = parseInt(size / 2, 10);<br>  return merge(sort(array.slice(0, mid)), sort(array.slice(mid)));<br>}</code></pre>
                        <pre name="6d8a" id="6d8a" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">/**</code></pre>
                        <pre name="0e50" id="0e50" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <pre name="aeab" id="aeab" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <ul class="postList">
                            <li name="9e63" id="9e63" class="graf graf--li graf-after--pre">Merge two arrays in asc order</li>
                            <li name="e171" id="e171" class="graf graf--li graf-after--li">@example</li>
                            <li name="9c18" id="9c18" class="graf graf--li graf-after--li">merge([2,5,9], [1,6,7]) =&gt; [1, 2, 5, 6, 7, 9]</li>
                            <li name="5c0c" id="5c0c" class="graf graf--li graf-after--li">@param {array} array1</li>
                            <li name="610e" id="610e" class="graf graf--li graf-after--li">@param {array} array2</li>
                            <li name="46f5" id="46f5" class="graf graf--li graf--empty graf-after--li"><br></li>
                        </ul>
                        <pre name="a282" id="a282" class="graf graf--pre graf--empty graf-after--li"><br></pre>
                        <p name="a8fd" id="a8fd" class="graf graf--p graf-after--pre">As you can see, it has two functions, <code class="markup--code markup--p-code">sort</code> and <code class="markup--code markup--p-code">merge</code>. Merge is an auxiliary function that runs once through the collection <code class="markup--code markup--p-code">a</code> and <code class="markup--code markup--p-code">b</code>, so it‚Äôs running time is O(n). Let‚Äôs apply the Master Method to find the running time.</p>
                        <h3 name="80d9" id="80d9" class="graf graf--h3 graf-after--p">Master Method for Mergesort</h3>
                        <p name="fa6b" id="fa6b" class="graf graf--p graf-after--h3">We are going to apply the <a href="https://github.com/bgoonz/2emulate/blob/master/most-popular-algorithms-time-complexity-every-programmer-should-know-free-online-tutorial-course/index.md#Master-Method-for-recursive-algorithms" data-href="https://github.com/bgoonz/2emulate/blob/master/most-popular-algorithms-time-complexity-every-programmer-should-know-free-online-tutorial-course/index.md#Master-Method-for-recursive-algorithms" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Master Method that we explained above</a> to find the runtime:</p>
                        <ol class="postList">
                            <li name="61a0" id="61a0" class="graf graf--li graf-after--p">Let‚Äôs find the values of: <code class="markup--code markup--li-code">T(n) = a T(n/b) + f(n)</code></li>
                            <li name="f43e" id="f43e" class="graf graf--li graf--empty graf-after--li"><br></li>
                        </ol>
                        <ul class="postList">
                            <li name="7766" id="7766" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">a</code>: The number of sub-problems is 2 (line 20). So, <code class="markup--code markup--li-code">a = 2</code>.</li>
                            <li name="cff6" id="cff6" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">b</code>: Each of the sub-problems divides <code class="markup--code markup--li-code">n</code> in half. So, <code class="markup--code markup--li-code">b = 2</code></li>
                            <li name="bffd" id="bffd" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">f(n)</code>: The work done outside the recursion is the function <code class="markup--code markup--li-code">merge</code>, which has a runtime of <code class="markup--code markup--li-code">O(n)</code> since it visits all the elements on the given arrays.</li>
                        </ul>
                        <ol class="postList">
                            <li name="2252" id="2252" class="graf graf--li graf--empty graf-after--li"><br></li>
                        </ol>
                        <p name="1044" id="1044" class="graf graf--p graf-after--li">Substituting the values:</p>
                        <blockquote name="1215" id="1215" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">T(n) = 2 T(n/2) + O(n)</em></blockquote>
                        <blockquote name="9039" id="9039" class="graf graf--blockquote graf--empty graf-after--blockquote"><br></blockquote>
                        <ol class="postList">
                            <li name="38c8" id="38c8" class="graf graf--li graf-after--blockquote">Let‚Äôs find the work done in the recursion: <code class="markup--code markup--li-code">nlogba</code>.</li>
                        </ol>
                        <p name="40c3" id="40c3" class="graf graf--p graf-after--li">nlog22</p>
                        <p name="f4b2" id="f4b2" class="graf graf--p graf-after--p">n1 = n</p>
                        <ol class="postList">
                            <li name="c50d" id="c50d" class="graf graf--li graf-after--p">Finally, we can see that recursion runtime from step 2) is O(n) and also the non-recursion runtime is O(n). So, we have the <a href="https://github.com/bgoonz/2emulate/blob/master/most-popular-algorithms-time-complexity-every-programmer-should-know-free-online-tutorial-course/index.md#Case-2-The-runtime-of-the-work-done-in-the-recursion-and-outside-is-the-same" data-href="https://github.com/bgoonz/2emulate/blob/master/most-popular-algorithms-time-complexity-every-programmer-should-know-free-online-tutorial-course/index.md#Case-2-The-runtime-of-the-work-done-in-the-recursion-and-outside-is-the-same" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">case 2</a>¬†: <code class="markup--code markup--li-code">O(nlogba log(n))</code></li>
                        </ol>
                        <p name="9dc6" id="9dc6" class="graf graf--p graf-after--li"><em class="markup--em markup--p-em">O(nlog22 log(n))</em></p>
                        <p name="a307" id="a307" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">O(n1 log(n))</em></p>
                        <p name="30e7" id="30e7" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">O(n log(n))</em> üëà this is running time of the merge sort</p>
                        <h3 name="115b" id="115b" class="graf graf--h3 graf-after--p">O(2^n)‚Ää‚Äî‚ÄäExponential time</h3>
                        <p name="0365" id="0365" class="graf graf--p graf-after--h3">Exponential (base 2) running time means that the calculations performed by an algorithm double every time as the input grows.</p>
                        <p name="7cc7" id="7cc7" class="graf graf--p graf-after--p">Examples of exponential runtime algorithms:</p>
                        <ul class="postList">
                            <li name="907e" id="907e" class="graf graf--li graf-after--p">Power Set: finding all the subsets on a set.</li>
                            <li name="1063" id="1063" class="graf graf--li graf-after--li">Fibonacci.</li>
                            <li name="e7fe" id="e7fe" class="graf graf--li graf-after--li">Travelling salesman problem using dynamic programming.</li>
                        </ul>
                        <h3 name="31c0" id="31c0" class="graf graf--h3 graf-after--li">Power Set</h3>
                        <p name="0c5c" id="0c5c" class="graf graf--p graf-after--h3">To understand the power set, let‚Äôs imagine you are buying a pizza. The store has many toppings that you can choose from, like pepperoni, mushrooms, bacon, and pineapple. Let‚Äôs call each topping A, B, C, D. What are your choices? You can select no topping (you are on a diet¬†;), you can choose one topping, or two or three or all of them, and so on. The power set gives you all the possibilities (BTW, there 16 with four toppings, as you will see later)</p>
                        <p name="9c13" id="9c13" class="graf graf--p graf-after--p">Finding all distinct subsets of a given set. For instance, let‚Äôs do some examples to try to come up with an algorithm to solve it:</p>
                        <pre name="1d54" id="1d54" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">1<br>2<br>3</code></pre>
                        <pre name="592b" id="592b" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <pre name="6d1e" id="6d1e" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">powerset(&#39;&#39;) // =&gt;  [&#39;&#39;]<br>powerset(&#39;a&#39;) // =&gt; [&#39;&#39;, &#39;a&#39;]<br>powerset(&#39;ab&#39;) // =&gt; [&#39;&#39;, &#39;a&#39;, &#39;b&#39;, &#39;ab&#39;]</code></pre>
                        <pre name="514f" id="514f" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <p name="bb4b" id="bb4b" class="graf graf--p graf-after--pre">Did you notice any pattern?</p>
                        <ul class="postList">
                            <li name="f9a8" id="f9a8" class="graf graf--li graf-after--p">The first returns an empty element.</li>
                            <li name="d994" id="d994" class="graf graf--li graf-after--li">The second case returns the empty element + the 1st element.</li>
                            <li name="25fe" id="25fe" class="graf graf--li graf-after--li">The 3rd case returns precisely the results of the 2nd case + the same array with the 2nd element <code class="markup--code markup--li-code">b</code> appended to it.</li>
                        </ul>
                        <p name="f010" id="f010" class="graf graf--p graf-after--li">What if you want to find the subsets of <code class="markup--code markup--p-code">abc</code>? Well, it would be precisely the subsets of ‚Äòab‚Äô and again the subsets of <code class="markup--code markup--p-code">ab</code> with <code class="markup--code markup--p-code">c</code> appended at the end of each element.</p>
                        <p name="615e" id="615e" class="graf graf--p graf-after--p">As you noticed, every time the input gets longer, the output is twice as long as the previous one. Let‚Äôs code it up:</p>
                        <pre name="4721" id="4721" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13</code></pre>
                        <pre name="28fb" id="28fb" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <pre name="c3ed" id="c3ed" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">function powerset(n = &#39;&#39;) {<br>  const array = Array.from(n);<br>  const base = [&#39;&#39;];</code></pre>
                        <pre name="0d67" id="0d67" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">const results = array.reduce((previous, element) =&gt; {<br>const previousPlusElement = previous.map(el =&gt; {<br>return ${el}${element};<br>});<br>return previous.concat(previousPlusElement);<br>}, base);</code></pre>
                        <pre name="3d76" id="3d76" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <pre name="bd3c" id="bd3c" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <pre name="df41" id="df41" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">return results;<br>}</code></pre>
                        <pre name="6f0b" id="6f0b" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <pre name="84d4" id="84d4" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <p name="3c08" id="3c08" class="graf graf--p graf-after--pre">If we run that function for a couple of cases we will get:</p>
                        <pre name="fd5b" id="fd5b" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12</code></pre>
                        <pre name="d236" id="d236" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <pre name="c4a1" id="c4a1" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">powerset(&#39;&#39;) // ...<br>// n = 0, f(n) = 1;<br>powerset(&#39;a&#39;) // , a...<br>// n = 1, f(n) = 2;<br>powerset(&#39;ab&#39;) // , a, b, ab...<br>// n = 2, f(n) = 4;<br>powerset(&#39;abc&#39;) // , a, b, ab, c, ac, bc, abc...<br>// n = 3, f(n) = 8;<br>powerset(&#39;abcd&#39;) // , a, b, ab, c, ac, bc, abc, d, ad, bd, abd, cd, acd, bcd...<br>// n = 4, f(n) = 16;<br>powerset(&#39;abcde&#39;) // , a, b, ab, c, ac, bc, abc, d, ad, bd, abd, cd, acd, bcd...<br>// n = 5, f(n) = 32;</code></pre>
                        <pre name="b795" id="b795" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <p name="7775" id="7775" class="graf graf--p graf-after--pre">As expected, if you plot <code class="markup--code markup--p-code">n</code> and <code class="markup--code markup--p-code">f(n)</code>, you will notice that it would be exactly like the function <code class="markup--code markup--p-code">2^n</code>. This algorithm has a running time of <code class="markup--code markup--p-code">O(2^n)</code>.</p>
                        <p name="a204" id="a204" class="graf graf--p graf-after--p">** Note:** You should avoid functions with exponential running times (if possible) since they don‚Äôt scale well. The time it takes to process the output doubles with every additional input size. But exponential running time is not the worst yet; others go even slower. Let‚Äôs see one more example in the next section.</p>
                        <h3 name="22c8" id="22c8" class="graf graf--h3 graf-after--p">O(n!)‚Ää‚Äî‚ÄäFactorial time</h3>
                        <p name="c143" id="c143" class="graf graf--p graf-after--h3">Factorial is the multiplication of all positive integer numbers less than itself. For instance:</p>
                        <blockquote name="c966" id="c966" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">5! = 5 x 4 x 3 x 2 x 1 = 120</em></blockquote>
                        <blockquote name="edfd" id="edfd" class="graf graf--blockquote graf--empty graf-after--blockquote"><br></blockquote>
                        <p name="9b9b" id="9b9b" class="graf graf--p graf-after--blockquote">It grows pretty quickly:</p>
                        <blockquote name="cd55" id="cd55" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">20! = 2,432,902,008,176,640,000</em></blockquote>
                        <blockquote name="21f9" id="21f9" class="graf graf--blockquote graf--empty graf-after--blockquote"><br></blockquote>
                        <p name="6783" id="6783" class="graf graf--p graf-after--blockquote">As you might guess, you want to stay away, if possible, from algorithms that have this running time!</p>
                        <p name="c1b4" id="c1b4" class="graf graf--p graf-after--p">Examples of O(n!) factorial runtime algorithms:</p>
                        <ul class="postList">
                            <li name="800f" id="800f" class="graf graf--li graf-after--p">Permutations of a string.</li>
                            <li name="87c9" id="87c9" class="graf graf--li graf-after--li">Solving the traveling salesman problem with a brute-force search</li>
                        </ul>
                        <p name="7ebd" id="7ebd" class="graf graf--p graf-after--li">Let‚Äôs solve the first example.</p>
                        <h3 name="0a66" id="0a66" class="graf graf--h3 graf-after--p">Permutations</h3>
                        <p name="e632" id="e632" class="graf graf--p graf-after--h3">Write a function that computes all the different words that can be formed given a string. E.g.</p>
                        <pre name="6733" id="6733" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">1<br>2<br>3</code></pre>
                        <pre name="4cd3" id="4cd3" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <pre name="5089" id="5089" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">getPermutations(&#39;a&#39;) // =&gt; [ &#39;a&#39;]<br>getPermutations(&#39;ab&#39;) // =&gt;  [ &#39;ab&#39;, &#39;ba&#39;]<br>getPermutations(&#39;abc&#39;) // =&gt; [ &#39;abc&#39;, &#39;acb&#39;, &#39;bac&#39;, &#39;bca&#39;, &#39;cab&#39;, &#39;cba&#39; ]</code></pre>
                        <pre name="cc86" id="cc86" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <p name="6806" id="6806" class="graf graf--p graf-after--pre">How would you solve that?</p>
                        <p name="fa63" id="fa63" class="graf graf--p graf-after--p">A straightforward way will be to check if the string has a length of 1. If so, return that string since you can‚Äôt arrange it differently.</p>
                        <p name="be27" id="be27" class="graf graf--p graf-after--p">For strings with a length bigger than 1, we could use recursion to divide the problem into smaller problems until we get to the length 1 case. We can take out the first character and solve the problem for the remainder of the string until we have a length of 1.</p>
                        <pre name="bc83" id="bc83" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11</code></pre>
                        <pre name="a6bf" id="a6bf" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <pre name="5b1f" id="5b1f" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">function getPermutations(string, prefix = &#39;&#39;) {<br>  if(string.length &lt;= 1) {<br>    return [prefix + string];<br>  }</code></pre>
                        <pre name="fee0" id="fee0" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">return Array.from(string).reduce((result, char, index) =&gt; {<br>const reminder = string.slice(0, index) + string.slice(index+1);<br>result = result.concat(getPermutations(reminder, prefix + char));<br>return result;<br>}, []);<br>}</code></pre>
                        <pre name="5f41" id="5f41" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <pre name="3e45" id="3e45" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <p name="fed7" id="fed7" class="graf graf--p graf-after--pre">If print out the output, it would be something like this:</p>
                        <pre name="cef9" id="cef9" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</code></pre>
                        <pre name="bf9c" id="bf9c" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <pre name="160a" id="160a" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">getPermutations(&#39;ab&#39;) // ab, ba...<br>// n = 2, f(n) = 2;<br>getPermutations(&#39;abc&#39;) // abc, acb, bac, bca, cab, cba...<br>// n = 3, f(n) = 6;<br>getPermutations(&#39;abcd&#39;) // abcd, abdc, acbd, acdb, adbc, adcb, bacd...<br>// n = 4, f(n) = 24;<br>getPermutations(&#39;abcde&#39;) // abcde, abced, abdce, abdec, abecd, abedc, acbde...<br>// n = 5, f(n) = 120;</code></pre>
                        <pre name="9f2b" id="9f2b" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <p name="2fdf" id="2fdf" class="graf graf--p graf-after--pre">I tried with a string with a length of 10. It took around 8 seconds!</p>
                        <pre name="5711" id="5711" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">1<br>2<br>3<br>4</code></pre>
                        <pre name="5c1b" id="5c1b" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <pre name="d941" id="d941" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">time node ./lib/permutations.js<br>## getPermutations(&#39;abcdefghij&#39;) // =&gt; abcdefghij, abcdefghji, abcdefgihj, abcdefgijh, abcdefgjhi, abcdefgjih, abcdefhgij...<br>## // n = 10, f(n) = 3,628,800;<br>## ./lib/permutations.js  8.06s user 0.63s system 101% cpu 8.562 total</code></pre>
                        <pre name="dd23" id="dd23" class="graf graf--pre graf--empty graf-after--pre"><br></pre>
                        <p name="dca2" id="dca2" class="graf graf--p graf-after--pre">I have a little homework for you:</p>
                        <blockquote name="5438" id="5438" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">Can you try with a permutation with 11 characters?¬†;) Comment below on what happened to your computer!</em></blockquote>
                        <blockquote name="b02a" id="b02a" class="graf graf--blockquote graf--empty graf-after--blockquote"><br></blockquote>
                        <h3 name="762b" id="762b" class="graf graf--h3 graf-after--blockquote">All running complexities graphs</h3>
                        <p name="ef33" id="ef33" class="graf graf--p graf-after--h3">We explored the most common algorithms running times with one or two examples each! They should give you an idea of how to calculate your running times when developing your projects. Below you can find a chart with a graph of all the time complexities that we covered:</p>
                        <figure name="2c06" id="2c06" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*4FY5xkjVIZDxoMEM.png" data-width="1003" data-height="809" src="https://cdn-images-1.medium.com/max/800/0*4FY5xkjVIZDxoMEM.png"></figure>
                        <p name="a1c0" id="a1c0" class="graf graf--p graf--empty graf-after--figure graf--trailing"><br></p>
                    </div>
                </div>
            </section>
        </section>
        <footer>
            <p><a href="https://medium.com/p/1dcac735d9ff">View original.</a></p>
            <p>Exported from <a href="https://medium.com">Medium</a> on October 14, 2021.</p>
        </footer>
    </article>
</body>

</html>
<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>What is “the Shell”?</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">What is “the Shell”?</h1>
</header>
<section data-field="subtitle" class="p-summary">
The magic conch is an almighty authority in SpongeBob. This godly item makes items like the Ultimate Nullifier and the Heart Of The…
</section>
<section data-field="body" class="e-content">
<section name="7b81" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="3b2a" id="3b2a" class="graf graf--h3 graf--leading graf--title"><strong class="markup--strong markup--h3-strong">What is “the Shell”?</strong></h3><h4 name="ec40" id="ec40" class="graf graf--h4 graf-after--h3 graf--subtitle"><strong class="markup--strong markup--h4-strong">The magic conch is an almighty authority in SpongeBob. This godly item makes items like the Ultimate Nullifier and the Heart Of The Universe look like playthings for babies.</strong></h4><p name="d8ec" id="d8ec" class="graf graf--p graf--empty graf-after--h4"><br></p><p name="8a9c" id="8a9c" class="graf graf--p graf--empty graf-after--p"><br></p><p name="ea75" id="ea75" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">The shell is a program that takes commands from the keyboard and gives them to the operating system to perform. In the old days, it was the only user interface available on a Unix-like system such as Linux. Nowadays, we have <em class="markup--em markup--p-em">graphical user interfaces (GUIs)</em> in addition to <em class="markup--em markup--p-em">command line interfaces (CLIs)</em> such as the shell.</strong></p><p name="e2cb" id="e2cb" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">On most Linux systems a program called </strong><a href="http://linuxcommand.org/lc3_man_pages/bash1.html" data-href="http://linuxcommand.org/lc3_man_pages/bash1.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">bash</strong></a><strong class="markup--strong markup--p-strong"> (which stands for Bourne Again SHell) an enhanced version of the original Unix shell program, sh, written by Steve Bourne) acts as the shell program. Besides bash, there are other shell programs available for Linux systems. These include: ksh, tcsh and zsh.</strong></p><p name="c322" id="c322" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">General Commands Manual</strong></p><p name="92f3" id="92f3" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">What’s a “Terminal?”</strong></p><p name="b9fb" id="b9fb" class="graf graf--p graf-after--p">It’s a program called a <em class="markup--em markup--p-em">terminal emulator</em>. This is a program that opens a window and lets you interact with the shell. There are a bunch of different terminal emulators we can use. Some Linux distributions install several. These might include <strong class="markup--strong markup--p-strong">gnome-terminal</strong>, <strong class="markup--strong markup--p-strong">konsole</strong>, <strong class="markup--strong markup--p-strong">xterm</strong>, <strong class="markup--strong markup--p-strong">rxvt</strong>, <strong class="markup--strong markup--p-strong">kvt</strong>, <strong class="markup--strong markup--p-strong">nxterm</strong>, and <strong class="markup--strong markup--p-strong">eterm</strong>.</p><p name="bee0" id="bee0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Starting a Terminal</strong></p><p name="97de" id="97de" class="graf graf--p graf-after--p">Window managers usually have a way to launch a terminal from the menu. Look through the list of programs to see if anything looks like a terminal emulator. While there are a number of different terminal emulators, they all do the same thing. They give us access to a shell session. You will probably develop a preference for one, based on the different bells and whistles it provides.</p><p name="1c00" id="1c00" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Testing the Keyboard</strong></p><p name="1e93" id="1e93" class="graf graf--p graf-after--p">OK, let’s try some typing. Bring up a terminal window. The first thing we should see is a <em class="markup--em markup--p-em">shell prompt</em> that contains our user name and the name of the machine followed by a dollar sign. Something like this:</p><p name="6d9c" id="6d9c" class="graf graf--p graf-after--p">[me@bgoonz me]$</p><p name="b5f0" id="b5f0" class="graf graf--p graf-after--p">Excellent! Now type some nonsense characters and press the enter key.</p><p name="dd75" id="dd75" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">kdkjflajfks</strong></p><p name="98b0" id="98b0" class="graf graf--p graf-after--p">If all went well, we should have gotten an error message complaining that it cannot understand the command:</p><p name="4989" id="4989" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">kdkjflajfks</strong> bash: kdkjflajfks: command not found</p><p name="409c" id="409c" class="graf graf--p graf-after--p">Wonderful! Now press the up-arrow key. Watch how our previous command “kdkjflajfks” returns. Yes, we have <em class="markup--em markup--p-em">command history</em>. Press the down-arrow and we get the blank line again.</p><p name="2bfc" id="2bfc" class="graf graf--p graf-after--p">Recall the “kdkjflajfks” command using the up-arrow key if needed. Now, try the left and right-arrow keys. We can position the text cursor anywhere in the command line. This allows us to easily correct mistakes.</p><p name="5d37" id="5d37" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">You’re not operating as root, are you?</strong></p><p name="a4fc" id="a4fc" class="graf graf--p graf-after--p">If the last character of your shell prompt is # rather than $, you are operating as the <em class="markup--em markup--p-em">superuser</em>. This means that you have administrative privileges. This can be dangerous, since you are able to delete or overwrite any file on the system. Unless you absolutely need administrative privileges, do not operate as the superuser.</p><p name="d8f6" id="d8f6" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Using the Mouse</strong></p><p name="693c" id="693c" class="graf graf--p graf-after--p">Even though the shell is a command line interface, the mouse is still handy.</p><p name="e77f" id="e77f" class="graf graf--p graf-after--p">Besides using the mouse to scroll the contents of the terminal window, we can can use it to copy text. Drag the mouse over some text (for example, “kdkjflajfks” right here on the browser window) while holding down the left button. The text should highlight. Release the left button and move the mouse pointer to the terminal window and press the middle mouse button (alternately, press both the left and right buttons at the same time when working on a touch pad). The text we highlighted in the browser window should be copied into the command line.</p><p name="2a23" id="2a23" class="graf graf--p graf-after--p">introduce our first three commands: <a href="http://linuxcommand.org/lc3_man_pages/pwdh.html" data-href="http://linuxcommand.org/lc3_man_pages/pwdh.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">pwd</strong></a> (print working directory), <a href="http://linuxcommand.org/lc3_man_pages/cdh.html" data-href="http://linuxcommand.org/lc3_man_pages/cdh.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">cd</strong></a> (change directory), and <a href="http://linuxcommand.org/lc3_man_pages/ls1.html" data-href="http://linuxcommand.org/lc3_man_pages/ls1.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">ls</strong></a> (list files and directories).</p><p name="21a8" id="21a8" class="graf graf--p graf-after--p">Those new to the command line will need to pay close attention to this lesson since the concepts will take some getting used to.</p><p name="9d8d" id="9d8d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">File System Organization</strong></p><p name="511d" id="511d" class="graf graf--p graf-after--p">Like Windows, the files on a Linux system are arranged in what is called a <em class="markup--em markup--p-em">hierarchical directory structure</em>. This means that they are organized in a tree-like pattern of <em class="markup--em markup--p-em">directories</em> (called folders in other systems), which may contain files and <em class="markup--em markup--p-em">subdirectories</em>. The first directory in the file system is called the <em class="markup--em markup--p-em">root directory</em>. The root directory contains files and subdirectories, which contain more files and subdirectories and so on and so on.</p><p name="b12b" id="b12b" class="graf graf--p graf-after--p">Most graphical environments include a file manager program used to view and manipulate the contents of the file system. Often we will see the file system represented like this:</p><p name="4761" id="4761" class="graf graf--p graf-after--p">One important difference between Windows and Unix-like operating systems such as Linux is that Linux does not employ the concept of drive letters. While Windows drive letters split the file system into a series of different trees (one for each device), Linux always has a single tree. Different storage devices may be different branches of the tree, but there is always just a single tree.</p><p name="eedd" id="eedd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">pwd</strong></p><p name="8aa2" id="8aa2" class="graf graf--p graf-after--p">Since the command line interface cannot provide graphic pictures of the file system structure, we must have a different way of representing it. To do this, think of the file system tree as a maze, and that we are standing in it. At any given moment, we are located in a single directory. Inside that directory, we can see its files and the pathway to its <em class="markup--em markup--p-em">parent directory</em> and the pathways to the subdirectories of the directory in which we are standing.</p><p name="a34c" id="a34c" class="graf graf--p graf-after--p">The directory we are standing in is called the <em class="markup--em markup--p-em">working directory</em>. To see the name of the working directory, we use the <strong class="markup--strong markup--p-strong">pwd</strong> command.</p><p name="307b" id="307b" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">pwd</strong> /home/me</p><p name="c74c" id="c74c" class="graf graf--p graf-after--p">When we first log on to our Linux system, the working directory is set to our <em class="markup--em markup--p-em">home directory</em>. This is where we put our files. On most systems, the home directory will be called /home/user_name, but it can be anything according to the whims of the system administrator.</p><p name="31b6" id="31b6" class="graf graf--p graf-after--p">To list the files in the working directory, we use the <strong class="markup--strong markup--p-strong">ls</strong> command.</p><p name="451a" id="451a" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">ls</strong> Desktop Downloads foo.txt Pictures Templates Documents examples.desktop Music Public Videos</p><p name="078d" id="078d" class="graf graf--p graf-after--p">We will come back to <strong class="markup--strong markup--p-strong">ls</strong> in the next lesson. There are a lot of fun things you can do with it, but we have to talk about pathnames and directories a bit first.</p><p name="cf02" id="cf02" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">cd</strong></p><p name="fb57" id="fb57" class="graf graf--p graf-after--p">To change the working directory (where we are standing in the maze) we use the <strong class="markup--strong markup--p-strong">cd</strong> command. To do this, we type <strong class="markup--strong markup--p-strong">cd</strong> followed by the <em class="markup--em markup--p-em">pathname</em> of the desired working directory. A pathname is the route we take along the branches of the tree to get to the directory we want. Pathnames can be specified two different ways; <em class="markup--em markup--p-em">absolute pathnames</em> or <em class="markup--em markup--p-em">relative pathnames</em>. Let’s look with absolute pathnames first.</p><p name="587c" id="587c" class="graf graf--p graf-after--p">An absolute pathname begins with the root directory and follows the tree branch by branch until the path to the desired directory or file is completed. For example, there is a directory on your system in which most programs are installed. The pathname of the directory is /usr/bin. This means from the root directory (represented by the leading slash in the pathname) there is a directory called “usr” which contains a directory called “bin”.</p><p name="82f5" id="82f5" class="graf graf--p graf-after--p">Let’s try this out:</p><p name="b9b7" id="b9b7" class="graf graf--p graf-after--p">me@bgoonz me]$ <strong class="markup--strong markup--p-strong">cd /usr/bin</strong> me@bgoonz bin]$ <strong class="markup--strong markup--p-strong">pwd</strong> /usr/bin me@bgoonz bin]$ <strong class="markup--strong markup--p-strong">ls</strong> ‘[‘ mshortname 2to3–2.7 mshowfat 411toppm mtools a2ps mtoolstest a2ps-lpr-wrapper mtr aa-enabled mtrace aa-exec mtr-packet aclocal mtvtoppm aclocal-1.15 mtype aconnect mutter acpi_listen mxtar add-apt-repository mzip addpart namei and many more…</p><p name="c329" id="c329" class="graf graf--p graf-after--p">Now we can see that we have changed the current working directory to /usr/bin and that it is full of files. Notice how the shell prompt has changed? As a convenience, it is usually set up to display the name of the working directory.</p><p name="22a2" id="22a2" class="graf graf--p graf-after--p">Where an absolute pathname starts from the root directory and leads to its destination, a relative pathname starts from the working directory. To do this, it uses a couple of special notations to represent relative positions in the file system tree. These special notations are “.” (dot) and “..” (dot dot).</p><p name="ad99" id="ad99" class="graf graf--p graf-after--p">The “.” notation refers to the working directory itself and the “..” notation refers to the working directory’s parent directory. Here is how it works. Let’s change the working directory to /usr/bin again:</p><p name="38fd" id="38fd" class="graf graf--p graf-after--p">me@bgoonz me]$ <strong class="markup--strong markup--p-strong">cd /usr/bin</strong> me@bgoonz bin]$ <strong class="markup--strong markup--p-strong">pwd</strong> /usr/bin</p><p name="129d" id="129d" class="graf graf--p graf-after--p">O.K., now let’s say that we wanted to change the working directory to the parent of /usr/bin which is /usr. We could do that two different ways. First, with an absolute pathname:</p><p name="17ce" id="17ce" class="graf graf--p graf-after--p">me@bgoonz bin]$ <strong class="markup--strong markup--p-strong">cd /usr</strong> me@bgoonz usr]$ <strong class="markup--strong markup--p-strong">pwd</strong> /usr</p><p name="814a" id="814a" class="graf graf--p graf-after--p">Or, with a relative pathname:</p><p name="41ca" id="41ca" class="graf graf--p graf-after--p">me@bgoonz bin]$ <strong class="markup--strong markup--p-strong">cd ..</strong> me@bgoonz usr]$ <strong class="markup--strong markup--p-strong">pwd</strong> /usr</p><p name="ceff" id="ceff" class="graf graf--p graf-after--p">Two different methods with identical results. Which one should we use? The one that requires the least typing!</p><p name="d033" id="d033" class="graf graf--p graf-after--p">Likewise, we can change the working directory from /usr to /usr/bin in two different ways. First using an absolute pathname:</p><p name="b57d" id="b57d" class="graf graf--p graf-after--p">me@bgoonz usr]$ <strong class="markup--strong markup--p-strong">cd /usr/bin</strong> me@bgoonz bin]$ <strong class="markup--strong markup--p-strong">pwd</strong> /usr/bin</p><p name="7c6d" id="7c6d" class="graf graf--p graf-after--p">Or, with a relative pathname:</p><p name="06d6" id="06d6" class="graf graf--p graf-after--p">me@bgoonz usr]$ <strong class="markup--strong markup--p-strong">cd ./bin</strong> me@bgoonz bin]$ <strong class="markup--strong markup--p-strong">pwd</strong> /usr/bin</p><p name="ec7b" id="ec7b" class="graf graf--p graf-after--p">Now, there is something important that we must point out here. In most cases, we can omit the “./”. It is implied. Typing:</p><p name="fb2b" id="fb2b" class="graf graf--p graf-after--p">me@bgoonz usr]$ <strong class="markup--strong markup--p-strong">cd bin</strong></p><p name="8271" id="8271" class="graf graf--p graf-after--p">would do the same thing. In general, if we do not specify a pathname to something, the working directory will be assumed. There is one important exception to this, but we won’t get to that for a while.</p><p name="5455" id="5455" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">A Few Shortcuts</strong></p><p name="da4a" id="da4a" class="graf graf--p graf-after--p">If we type <strong class="markup--strong markup--p-strong">cd</strong> followed by nothing, <strong class="markup--strong markup--p-strong">cd</strong> will change the working directory to our home directory.</p><p name="947b" id="947b" class="graf graf--p graf-after--p">A related shortcut is to type <strong class="markup--strong markup--p-strong">cd ~<em class="markup--em markup--p-em">user_name</em></strong>. In this case, <strong class="markup--strong markup--p-strong">cd</strong> will change the working directory to the home directory of the specified user.</p><p name="83c1" id="83c1" class="graf graf--p graf-after--p">Typing <strong class="markup--strong markup--p-strong">cd </strong>— changes the working directory to the previous one.</p><p name="c0d8" id="c0d8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Important facts about file names</strong></p><p name="9df2" id="9df2" class="graf graf--p graf-after--p">1. File names that begin with a period character are hidden. This only means that <strong class="markup--strong markup--p-strong">ls</strong> will not list them unless we say <strong class="markup--strong markup--p-strong">ls -a</strong>. When your account was created, several hidden files were placed in your home directory to configure things for your account. Later on we will take a closer look at some of these files to see how you can customize our <em class="markup--em markup--p-em">environment</em>. In addition, some applications will place their configuration and settings files in your home directory as hidden files.</p><p name="151a" id="151a" class="graf graf--p graf-after--p">2. File names in Linux, like Unix, are case sensitive. The file names “File1” and “file1” refer to different files.</p><p name="d8c0" id="d8c0" class="graf graf--p graf-after--p">3. Linux has no concept of a “file extension” like Windows systems. You may name files any way you like. However, while Linux itself does not care about file extensions, many application programs do.</p><p name="5afe" id="5afe" class="graf graf--p graf-after--p">4. Though Linux supports long file names which may contain embedded spaces and punctuation characters, limit the punctuation characters to period, dash, and underscore. <strong class="markup--strong markup--p-strong">Most importantly, do not embed spaces in file names.</strong> If you want to represent spaces between words in a file name, use underscore characters. You will thank yourself later.</p><p name="c8a8" id="c8a8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Looking Around</strong></p><p name="797e" id="797e" class="graf graf--p graf-after--p">Now that we know how to move from working directory to working directory, we’re going to take a tour of our Linux system and, along the way, learn some things about what makes it tick. But before we begin, we have to learn about some tools that will come in handy during our journey. These are:</p><ul class="postList"><li name="c3f1" id="c3f1" class="graf graf--li graf-after--p"><a href="http://linuxcommand.org/lc3_man_pages/ls1.html" data-href="http://linuxcommand.org/lc3_man_pages/ls1.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">ls</strong></a> (list files and directories)</li><li name="6a5c" id="6a5c" class="graf graf--li graf-after--li"><a href="http://linuxcommand.org/lc3_man_pages/less1.html" data-href="http://linuxcommand.org/lc3_man_pages/less1.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">less</strong></a> (view text files)</li><li name="d334" id="d334" class="graf graf--li graf-after--li"><a href="http://linuxcommand.org/lc3_man_pages/file1.html" data-href="http://linuxcommand.org/lc3_man_pages/file1.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">file</strong></a> (classify a file’s contents)</li></ul><p name="75d9" id="75d9" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">ls</strong></p><p name="1e89" id="1e89" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">ls</strong> command is used to list the contents of a directory. It is probably the most commonly used Linux command. It can be used in a number of different ways. Here are some examples:</p><p name="1a1b" id="1a1b" class="graf graf--p graf-after--p">These examples also point out an important concept about commands. Most commands operate like this:</p><p name="337d" id="337d" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">command -options arguments</em></p><p name="f336" id="f336" class="graf graf--p graf-after--p">where <em class="markup--em markup--p-em">command</em> is the name of the command, <em class="markup--em markup--p-em">-options</em> is one or more adjustments to the command’s behavior, and <em class="markup--em markup--p-em">arguments</em> is one or more “things” upon which the command operates.</p><p name="5184" id="5184" class="graf graf--p graf-after--p">In the case of <strong class="markup--strong markup--p-strong">ls</strong>, we see that <strong class="markup--strong markup--p-strong">ls</strong> is the name of the command, and that it can have one or more options, such as <strong class="markup--strong markup--p-strong">-a</strong> and <strong class="markup--strong markup--p-strong">-l</strong>, and it can operate on one or more files or directories.</p><p name="c6de" id="c6de" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">A Closer Look at Long Format</strong></p><p name="3173" id="3173" class="graf graf--p graf-after--p">If we use the <strong class="markup--strong markup--p-strong">-l</strong> option with <strong class="markup--strong markup--p-strong">ls</strong>, you will get a file listing that contains a wealth of information about the files being listed. Here’s an example:</p><p name="d9d0" id="d9d0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">-rw — — — — 1 me me 576 Apr 17 2019 weather.txt<br> drwxr-xr-x 6 me me 1024 Oct 9 2019 web_page<br> -rw-rw-r — 1 me me 276480 Feb 11 20:41 web_site.tar<br> -rw — — — — 1 me me 5743 Dec 16 2018 xmas_file.txt<br> <br> — — — — — — — — — — — — — — — — — — — — — — — — — — — — — -<br> | | | | | |<br> | | | | | File Name<br> | | | | |<br> | | | | + — — Modification Time<br> | | | |<br> | | | + — — — — — — — Size (in bytes)<br> | | |<br> | | + — — — — — — — — — — — — Group<br> | |<br> | + — — — — — — — — — — — — — — — — Owner<br> |<br> + — — — — — — — — — — — — — — — — — — — — — — — File Permissions</strong></p><p name="b1c5" id="b1c5" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">File Name</strong>The name of the file or directory.<strong class="markup--strong markup--p-strong">Modification Time</strong>The last time the file was modified. If the last modification occurred more than six months in the past, the date and year are displayed. Otherwise, the time of day is shown.<strong class="markup--strong markup--p-strong">Size</strong>The size of the file in bytes.<strong class="markup--strong markup--p-strong">Group</strong>The name of the group that has file permissions in addition to the file’s owner.<strong class="markup--strong markup--p-strong">Owner</strong>The name of the user who owns the file.<strong class="markup--strong markup--p-strong">File Permissions</strong>A representation of the file’s access permissions. The first character is the type of file. A “-” indicates a regular (ordinary) file. A “d” indicates a directory. The second set of three characters represent the read, write, and execution rights of the file’s owner. The next three represent the rights of the file’s group, and the final three represent the rights granted to everybody else. We’ll discuss this in more detail in a later lesson.</p><p name="ffd5" id="ffd5" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">less</strong></p><p name="a84d" id="a84d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">less</strong> is a program that lets us view text files. This is very handy since many of the files used to control and configure Linux are human readable.</p><p name="d2d1" id="d2d1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">What is “text”?</strong></p><p name="2e7c" id="2e7c" class="graf graf--p graf-after--p">There are many ways to represent information on a computer. All methods involve defining a relationship between the information and some numbers that will be used to represent it. Computers, after all, only understand numbers and all data is converted to numeric representation.</p><p name="d20e" id="d20e" class="graf graf--p graf-after--p">Some of these representation systems are very complex (such as compressed multimedia files), while others are rather simple. One of the earliest and simplest is called <em class="markup--em markup--p-em">ASCII text</em>. <a href="http://linuxcommand.org/lc3_man_pages/ascii7.html" data-href="http://linuxcommand.org/lc3_man_pages/ascii7.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">ASCII</a> (pronounced “As-Key”) is short for American Standard Code for Information Interchange. This is a simple encoding scheme that was first used on Teletype machines to map keyboard characters to numbers.</p><p name="7889" id="7889" class="graf graf--p graf-after--p">Text is a simple one-to-one mapping of characters to numbers. It is very compact. Fifty characters of text translates to fifty bytes of data. Throughout a Linux system, many files are stored in text format and there are many Linux tools that work with text files. Even Windows systems recognize the importance of this format. The well-known NOTEPAD.EXE program is an editor for plain ASCII text files.</p><p name="52e3" id="52e3" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">less</strong> program is invoked by simply typing:</p><p name="0f63" id="0f63" class="graf graf--p graf-after--p">less <em class="markup--em markup--p-em">text_file</em></p><p name="50cb" id="50cb" class="graf graf--p graf-after--p">This will display the file.</p><p name="413f" id="413f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Controlling less</strong></p><p name="f74f" id="f74f" class="graf graf--p graf-after--p">Once started, <strong class="markup--strong markup--p-strong">less</strong> will display the text file one page at a time. We can use the Page Up and Page Down keys to move through the text file. To exit <strong class="markup--strong markup--p-strong">less</strong>, we type “q”. Here are some commands that <strong class="markup--strong markup--p-strong">less</strong> will accept:</p><p name="1dcc" id="1dcc" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">file</strong></p><p name="a9be" id="a9be" class="graf graf--p graf-after--p">As we wander around our Linux system, it is helpful to determine what kind of data a file contains before we try to view it. This is where the <strong class="markup--strong markup--p-strong">file</strong> command comes in. <strong class="markup--strong markup--p-strong">file</strong> will examine a file and tell us what kind of file it is.</p><p name="03b0" id="03b0" class="graf graf--p graf-after--p">To use the <strong class="markup--strong markup--p-strong">file</strong> program, we just type:</p><p name="5963" id="5963" class="graf graf--p graf-after--p">file <em class="markup--em markup--p-em">name_of_file</em></p><p name="ffb6" id="ffb6" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">file</strong> program can recognize most types of files, such as:</p><p name="428f" id="428f" class="graf graf--p graf-after--p">While it may seem that most files cannot be viewed as text, a surprising number can be. This is especially true of the important configuration files. During our adventure we will see that many features of the operating system are controlled by text configuration files and shell scripts. In Linux, there are no secrets!</p><p name="c4f5" id="c4f5" class="graf graf--p graf-after--p">For each of the directories listed below, do the following:</p><ul class="postList"><li name="b096" id="b096" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">cd</strong> into each directory.</li><li name="9adc" id="9adc" class="graf graf--li graf-after--li">Use <strong class="markup--strong markup--li-strong">ls</strong> to list the contents of the directory.</li><li name="d400" id="d400" class="graf graf--li graf-after--li">If there is an interesting file, use the <strong class="markup--strong markup--li-strong">file</strong> command to determine its contents.</li><li name="f869" id="f869" class="graf graf--li graf-after--li">For text files, use <strong class="markup--strong markup--li-strong">less</strong> to view them.</li></ul><p name="722c" id="722c" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">A weird kind of file…</strong></p><p name="9335" id="9335" class="graf graf--p graf-after--p">During your tour, you probably noticed a strange kind of directory entry, particularly in the <strong class="markup--strong markup--p-strong">/lib</strong> directory. When listed with <strong class="markup--strong markup--p-strong">ls -l</strong>, you might have seen something like this:</p><p name="2343" id="2343" class="graf graf--p graf-after--p">lrwxrwxrwx 25 Jul 3 16:42 System.map -&gt; /boot/System.map-4.0.36–3<br> -rw-r — r — 105911 Oct 13 2018 System.map-4.0.36–0.7<br> -rw-r — r — 105935 Dec 29 2018 System.map-4.0.36–3<br> -rw-r — r — 181986 Dec 11 2019 initrd-4.0.36–0.7.img<br> -rw-r — r — 182001 Dec 11 2019 initrd-4.0.36.img<br> lrwxrwxrwx 26 Jul 3 16:42 module-info -&gt; /boot/module-info-4.0.36–3<br> -rw-r — r — 11773 Oct 13 2018 module-info-4.0.36–0.7<br> -rw-r — r — 11773 Dec 29 2018 module-info-4.0.36–3<br> lrwxrwxrwx 16 Dec 11 2019 vmlinuz -&gt; vmlinuz-4.0.36–3<br> -rw-r — r — 454325 Oct 13 2018 vmlinuz-4.0.36–0.7<br> -rw-r — r — 454434 Dec 29 2018 vmlinuz-4.0.36–3</p><p name="8ea1" id="8ea1" class="graf graf--p graf-after--p">Notice the files, System.map, module-info and vmlinuz. See the strange notation after the file names?</p><p name="0615" id="0615" class="graf graf--p graf-after--p">Files such as this are called <em class="markup--em markup--p-em">symbolic links</em>. Symbolic links are a special type of file that points to another file. With symbolic links, it is possible for a single file to have multiple names. Here’s how it works: Whenever the system is given a file name that is a symbolic link, it transparently maps it to the file it is pointing to.</p><p name="125f" id="125f" class="graf graf--p graf-after--p">Just what is this good for? This is a very handy feature. Let’s consider the directory listing above (which is the /boot directory of an old system). This system has had multiple versions of the Linux kernel installed. We can see this from the files vmlinuz-4.0.36–0.7 and vmlinuz-4.0.36–3. These file names suggest that both version 4.0.36–0.7 and 4.0.36–3 are installed. Because the file names contain the version it is easy to see the differences in the directory listing. However, this would be confusing to programs that rely on a fixed name for the kernel file. These programs might expect the kernel to simply be called “vmlinuz”. Here is where the beauty of the symbolic link comes in. By creating a symbolic link called vmlinuz that points to vmlinuz-4.0.36–3, we have solved the problem.</p><p name="f3d5" id="f3d5" class="graf graf--p graf-after--p">To create symbolic links, we use the <a href="http://linuxcommand.org/lc3_man_pages/ln1.html" data-href="http://linuxcommand.org/lc3_man_pages/ln1.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">ln</strong></a> command.</p><p name="b45f" id="b45f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Manipulating Files</strong></p><p name="5e10" id="5e10" class="graf graf--p graf-after--p">This lesson will introduce the following commands:</p><ul class="postList"><li name="423a" id="423a" class="graf graf--li graf-after--p"><a href="http://linuxcommand.org/lc3_man_pages/cp1.html" data-href="http://linuxcommand.org/lc3_man_pages/cp1.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">cp</strong></a> — copy files and directories</li><li name="ba49" id="ba49" class="graf graf--li graf-after--li"><a href="http://linuxcommand.org/lc3_man_pages/mv1.html" data-href="http://linuxcommand.org/lc3_man_pages/mv1.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">mv</strong></a> — move or rename files and directories</li><li name="0684" id="0684" class="graf graf--li graf-after--li"><a href="http://linuxcommand.org/lc3_man_pages/rm1.html" data-href="http://linuxcommand.org/lc3_man_pages/rm1.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">rm</strong></a> — remove files and directories</li><li name="2cdc" id="2cdc" class="graf graf--li graf-after--li"><a href="http://linuxcommand.org/lc3_man_pages/mkdir1.html" data-href="http://linuxcommand.org/lc3_man_pages/mkdir1.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">mkdir</strong></a> — create directories</li></ul><p name="df21" id="df21" class="graf graf--p graf-after--li">These four commands are among the most frequently used Linux commands. They are the basic commands for manipulating both files and directories.</p><p name="8fef" id="8fef" class="graf graf--p graf-after--p">Now, to be frank, some of the tasks performed by these commands are more easily done with a graphical file manager. With a file manager, you can drag and drop a file from one directory to another, cut and paste files, delete files, etc. So why use these old command line programs?</p><p name="8e85" id="8e85" class="graf graf--p graf-after--p">The answer is power and flexibility. While it is easy to perform simple file manipulations with a graphical file manager, complicated tasks can be easier with the command line programs. For example, how would you copy all the HTML files from one directory to another, but only copy files that did not exist in the destination directory or were newer than the versions in the destination directory? Pretty hard with with a file manager. Pretty easy with the command line:</p><p name="b89e" id="b89e" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">cp -u *.html destination</strong></p><p name="41c7" id="41c7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Wildcards</strong></p><p name="4d88" id="4d88" class="graf graf--p graf-after--p">Before we begin with our commands, we’ll first look at a shell feature that makes these commands so powerful. Since the shell uses filenames so much, it provides special characters to help you rapidly specify groups of filenames. These special characters are called <em class="markup--em markup--p-em">wildcards</em>. Wildcards allow you to select filenames based on patterns of characters. The table below lists the wildcards and what they select:</p><p name="8431" id="8431" class="graf graf--p graf-after--p">We can use wildcards with any command that accepts filename arguments.</p><p name="8764" id="8764" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">cp</strong></p><p name="f8c4" id="f8c4" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">cp</strong> program copies files and directories. In its simplest form, it copies a single file:</p><p name="3dcb" id="3dcb" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">cp <em class="markup--em markup--p-em">file1 file2</em></strong></p><p name="b511" id="b511" class="graf graf--p graf-after--p">It can also be used to copy multiple files (and/or directories) to a different directory:</p><p name="511a" id="511a" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">cp <em class="markup--em markup--p-em">file… directory</em></strong></p><p name="9cbd" id="9cbd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">A note on notation:</strong> … signifies that an item can be repeated one or more times.</p><p name="0084" id="0084" class="graf graf--p graf-after--p">Other useful examples of <strong class="markup--strong markup--p-strong">cp</strong> and its options include:</p><p name="fa6c" id="fa6c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">mv</strong></p><p name="a05e" id="a05e" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">mv</strong> command moves or renames files and directories depending on how it is used. It will either move one or more files to a different directory, or it will rename a file or directory. To rename a file, it is used like this:</p><p name="dfbc" id="dfbc" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">mv <em class="markup--em markup--p-em">filename1 filename2</em></strong></p><p name="fc58" id="fc58" class="graf graf--p graf-after--p">To move files (and/or directories) to a different directory:</p><p name="7475" id="7475" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">mv <em class="markup--em markup--p-em">file… directory</em></strong></p><p name="395a" id="395a" class="graf graf--p graf-after--p">Examples of <strong class="markup--strong markup--p-strong">mv</strong> and its options include:</p><p name="79e1" id="79e1" class="graf graf--p graf-after--p">Be careful with rm!</p><p name="db4a" id="db4a" class="graf graf--p graf-after--p">Linux does not have an undelete command. Once you delete something with <strong class="markup--strong markup--p-strong">rm</strong>, it’s gone. You can inflict terrific damage on your system with <strong class="markup--strong markup--p-strong">rm</strong> if you are not careful, particularly with wildcards.</p><p name="6a8c" id="6a8c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Before you use </em>rm<em class="markup--em markup--p-em"> with wildcards, try this helpful trick:</em></strong> construct your command using <strong class="markup--strong markup--p-strong">ls</strong> instead. By doing this, you can see the effect of your wildcards before you delete files. After you have tested your command with <strong class="markup--strong markup--p-strong">ls</strong>, recall the command with the up-arrow key and then substitute <strong class="markup--strong markup--p-strong">rm</strong> for <strong class="markup--strong markup--p-strong">ls</strong> in the command.</p><p name="c01f" id="c01f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">mkdir</strong></p><p name="8625" id="8625" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">mkdir</strong> command is used to create directories. To use it, you simply type:</p><p name="fcd6" id="fcd6" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">mkdir <em class="markup--em markup--p-em">directory…</em></strong></p><p name="4dbd" id="4dbd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Using Commands with Wildcards</strong></p><p name="52d5" id="52d5" class="graf graf--p graf-after--p">Since the commands we have covered here accept multiple file and directories names as arguments, you can use wildcards to specify them. Here are a few examples:</p><p name="1eb3" id="1eb3" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Working with Commands</strong></p><p name="5ba8" id="5ba8" class="graf graf--p graf-after--p">Up until now, we have seen a number of commands and their mysterious options and arguments. In this lesson, we will try to remove some of that mystery. We will introduce the following commands.</p><ul class="postList"><li name="289a" id="289a" class="graf graf--li graf-after--p"><a href="http://linuxcommand.org/lc3_man_pages/typeh.html" data-href="http://linuxcommand.org/lc3_man_pages/typeh.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">type</strong></a> — Display information about command type</li><li name="bbc4" id="bbc4" class="graf graf--li graf-after--li"><a href="http://linuxcommand.org/lc3_man_pages/which1.html" data-href="http://linuxcommand.org/lc3_man_pages/which1.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">which</strong></a> — Locate a command</li><li name="b142" id="b142" class="graf graf--li graf-after--li"><a href="http://linuxcommand.org/lc3_man_pages/helph.html" data-href="http://linuxcommand.org/lc3_man_pages/helph.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">help</strong></a> — Display reference page for shell builtin</li><li name="19b8" id="19b8" class="graf graf--li graf-after--li"><a href="http://linuxcommand.org/lc3_man_pages/man1.html" data-href="http://linuxcommand.org/lc3_man_pages/man1.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">man</strong></a> — Display an on-line command reference</li></ul><p name="96c3" id="96c3" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">What are “Commands?”</strong></p><p name="4fc8" id="4fc8" class="graf graf--p graf-after--p">Commands can be one of 4 different kinds:</p><p name="f73e" id="f73e" class="graf graf--p graf-after--p">1. <strong class="markup--strong markup--p-strong">An executable program</strong> like all those files we saw in /usr/bin. Within this category, programs can be <em class="markup--em markup--p-em">compiled binaries</em> such as programs written in C and C++, or programs written in <em class="markup--em markup--p-em">scripting languages</em> such as the shell, Perl, Python, Ruby, etc.</p><p name="a5a2" id="a5a2" class="graf graf--p graf-after--p">2. <strong class="markup--strong markup--p-strong">A command built into the shell itself.</strong> bash provides a number of commands internally called <em class="markup--em markup--p-em">shell builtins</em>. The <strong class="markup--strong markup--p-strong">cd</strong> command, for example, is a shell builtin.</p><p name="efbc" id="efbc" class="graf graf--p graf-after--p">3. <strong class="markup--strong markup--p-strong">A shell function.</strong> These are miniature shell scripts incorporated into the <em class="markup--em markup--p-em">environment</em>. We will cover configuring the environment and writing shell functions in later lessons, but for now, just be aware that they exist.</p><p name="7373" id="7373" class="graf graf--p graf-after--p">4. <strong class="markup--strong markup--p-strong">An alias.</strong> Commands that we can define ourselves, built from other commands. This will be covered in a later lesson.</p><p name="76c8" id="76c8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Identifying Commands</strong></p><p name="0bdd" id="0bdd" class="graf graf--p graf-after--p">It is often useful to know exactly which of the four kinds of commands is being used and Linux provides a couple of ways to find out.</p><p name="aa7f" id="aa7f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">type</strong></p><p name="16d1" id="16d1" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">type</strong> command is a shell builtin that displays the kind of command the shell will execute, given a particular command name. It works like this:</p><p name="e770" id="e770" class="graf graf--p graf-after--p">type <em class="markup--em markup--p-em">command</em></p><p name="09e3" id="09e3" class="graf graf--p graf-after--p">where “command” is the name of the command we want to examine. Here are some examples:</p><p name="b681" id="b681" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">type type</strong> type is a shell builtin [me@bgoonz me]$ <strong class="markup--strong markup--p-strong">type ls</strong> s is aliased to `ls — color=auto’ [me@bgoonz me]$ <strong class="markup--strong markup--p-strong">type cp</strong> cp is /bin/cp</p><p name="5529" id="5529" class="graf graf--p graf-after--p">Here we see the results for three different commands. Notice that the one for <strong class="markup--strong markup--p-strong">ls</strong> and how the ls command is actually an alias for the <strong class="markup--strong markup--p-strong">ls</strong> command with the “ — color=auto” option added. Now we know why the output from <strong class="markup--strong markup--p-strong">ls</strong> is displayed in color!</p><p name="5f43" id="5f43" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">which</strong></p><p name="41e6" id="41e6" class="graf graf--p graf-after--p">Sometimes there is more than one version of an executable program installed on a system. While this is not very common on desktop systems, it’s not unusual on large servers. To determine the exact location of a given executable, the <strong class="markup--strong markup--p-strong">which</strong> command is used:</p><p name="4df3" id="4df3" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">which ls</strong> /bin/ls</p><p name="60ab" id="60ab" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">which</strong> only works for executable programs, not builtins nor aliases that are substitutes for actual executable programs.</p><p name="fa59" id="fa59" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Getting Command Documentation</strong></p><p name="1ffd" id="1ffd" class="graf graf--p graf-after--p">With this knowledge of what a command is, we can now search for the documentation available for each kind of command.</p><p name="d560" id="d560" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">help</strong></p><p name="0b3f" id="0b3f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">bash</strong> has a built-in help facility available for each of the shell builtins. To use it, type “help” followed by the name of the shell builtin. Optionally, we can add the -m option to change the format of the output. For example:</p><p name="6238" id="6238" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">help -m cd</strong> NAME cd — Change the shell working directory. SYNOPSIS cd [-L|-P] [dir] DESCRIPTION Change the shell working directory. Change the current directory to DIR. The default DIR is the value of the HOME shell variable. The variable CDPATH defines the search path for the directory containing DIR. Alternative directory names in CDPATH are separated by a colon (:). A null directory name is the same as the current directory. If DIR begins with a slash (/), then CDPATH is not used. If the directory is not found, and the shell option `cdable_vars’ is set, the word is assumed to be a variable name. If that variable has a value, its value is used for DIR. Options: -L force symbolic links to be followed -P use the physical directory structure without following symbolic links The default is to follow symbolic links, as if `-L’ were specified. Exit Status: Returns 0 if the directory is changed; non-zero otherwise. SEE ALSO bash(1) IMPLEMENTATION GNU bash, version 4.1.5(1)-release (i486-pc-linux-gnu) Copyright © 2009 Free Software Foundation, Inc.</p><p name="f7f0" id="f7f0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">A note on notation:</strong> When square brackets appear in the description of a command’s syntax, they indicate optional items. A vertical bar character indicates mutually exclusive items. In the case of the <strong class="markup--strong markup--p-strong">cd</strong> command above:</p><p name="a97b" id="a97b" class="graf graf--p graf-after--p">cd [-L|-P] [dir]</p><p name="0566" id="0566" class="graf graf--p graf-after--p">This notation says that the command <strong class="markup--strong markup--p-strong">cd</strong> may be followed optionally by either a “-L” or a “-P” and further, optionally followed by the argument “dir”.</p><p name="e67d" id="e67d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">— help</strong></p><p name="b6c7" id="b6c7" class="graf graf--p graf-after--p">Many executable programs support a “ — help” option that displays a description of the command’s supported syntax and options. For example:</p><p name="bf70" id="bf70" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">mkdir — help</strong> Usage: mkdir [OPTION] DIRECTORY… Create the DIRECTORY(ies), if they do not already exist. Mandatory arguments to long options are mandatory for short options too. -Z, — context=CONTEXT (SELinux) set security context to CONTEXT -m, — mode=MODE set file mode (as in chmod), not a=rwx — umask -p, — parents no error if existing, make parent directories as needed -v, — verbose print a message for each created directory — help display this help and exit — version output version information and exit</p><p name="035b" id="035b" class="graf graf--p graf-after--p">Some programs don’t support the “ — help” option, but try it anyway. Often it results in an error message that will reveal similar usage information.</p><p name="9a13" id="9a13" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">man</strong></p><p name="9d19" id="9d19" class="graf graf--p graf-after--p">Most executable programs intended for command line use provide a formal piece of documentation called a <em class="markup--em markup--p-em">manual</em> or <em class="markup--em markup--p-em">man page</em>. A special paging program called <strong class="markup--strong markup--p-strong">man</strong> is used to view them. It is used like this:</p><p name="20aa" id="20aa" class="graf graf--p graf-after--p">man <em class="markup--em markup--p-em">program</em></p><p name="73dc" id="73dc" class="graf graf--p graf-after--p">where “program” is the name of the command to view. Man pages vary somewhat in format but generally contain a title, a synopsis of the command’s syntax, a description of the command’s purpose, and a listing and description of each of the command’s options. Man pages, however, do not usually include examples, and are intended as a reference, not a tutorial. Let’s try viewing the man page for the <strong class="markup--strong markup--p-strong">ls</strong> command:</p><p name="9143" id="9143" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">man ls</strong></p><p name="38d8" id="38d8" class="graf graf--p graf-after--p">On most Linux systems, <strong class="markup--strong markup--p-strong">man</strong> uses <strong class="markup--strong markup--p-strong">less</strong> to display the manual page, so all of the familiar <strong class="markup--strong markup--p-strong">less</strong> commands work while displaying the page.</p><p name="4e05" id="4e05" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">README and Other Documentation Files</strong></p><p name="3ae3" id="3ae3" class="graf graf--p graf-after--p">Many software packages installed on your system have documentation files residing in the /usr/share/doc directory. Most of these are stored in plain text format and can be viewed with <strong class="markup--strong markup--p-strong">less</strong>. Some of the files are in HTML format and can be viewed with a web browser. We may encounter some files ending with a “.gz” extension. This indicates that they have been compressed with the <strong class="markup--strong markup--p-strong">gzip</strong> compression program. The gzip package includes a special version of <strong class="markup--strong markup--p-strong">less</strong> called <strong class="markup--strong markup--p-strong">zless</strong> that will display the contents of gzip-compressed text files.</p><p name="4447" id="4447" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">I/O Redirection</strong></p><p name="f3de" id="f3de" class="graf graf--p graf-after--p">In this lesson, we will explore a powerful feature used by command line programs called <em class="markup--em markup--p-em">input/output redirection</em>. As we have seen, many commands such as <strong class="markup--strong markup--p-strong">ls</strong> print their output on the display. This does not have to be the case, however. By using some special notations we can <em class="markup--em markup--p-em">redirect</em> the output of many commands to files, devices, and even to the input of other commands.</p><p name="f800" id="f800" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Standard Output</strong></p><p name="8d34" id="8d34" class="graf graf--p graf-after--p">Most command line programs that display their results do so by sending their results to a facility called <em class="markup--em markup--p-em">standard output</em>. By default, standard output directs its contents to the display. To redirect standard output to a file, the “&gt;” character is used like this:</p><p name="6e33" id="6e33" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">ls &gt; file_list.txt</strong></p><p name="ef5a" id="ef5a" class="graf graf--p graf-after--p">In this example, the <strong class="markup--strong markup--p-strong">ls</strong> command is executed and the results are written in a file named file_list.txt. Since the output of <strong class="markup--strong markup--p-strong">ls</strong> was redirected to the file, no results appear on the display.</p><p name="4857" id="4857" class="graf graf--p graf-after--p">Each time the command above is repeated, file_list.txt is overwritten from the beginning with the output of the command <strong class="markup--strong markup--p-strong">ls</strong>. To have the new results <em class="markup--em markup--p-em">appended</em> to the file instead, we use “&gt;&gt;” like this:</p><p name="44b2" id="44b2" class="graf graf--p graf-after--p">[me@bgoonz me]$<strong class="markup--strong markup--p-strong">ls &gt;&gt; file_list.txt</strong></p><p name="a7cc" id="a7cc" class="graf graf--p graf-after--p">When the results are appended, the new results are added to the end of the file, thus making the file longer each time the command is repeated. If the file does not exist when we attempt to append the redirected output, the file will be created.</p><p name="5e76" id="5e76" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Standard Input</strong></p><p name="66ef" id="66ef" class="graf graf--p graf-after--p">Many commands can accept input from a facility called <em class="markup--em markup--p-em">standard input</em>. By default, standard input gets its contents from the keyboard, but like standard output, it can be redirected. To redirect standard input from a file instead of the keyboard, the “&lt;” character is used like this:</p><p name="2dd6" id="2dd6" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">sort &lt; file_list.txt</strong></p><p name="57a9" id="57a9" class="graf graf--p graf-after--p">In the example above, we used the <a href="http://linuxcommand.org/lc3_man_pages/sort1.html" data-href="http://linuxcommand.org/lc3_man_pages/sort1.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">sort</strong></a> command to process the contents of file_list.txt. The results are output on the display since the standard output was not redirected. We could redirect standard output to another file like this:</p><p name="01ec" id="01ec" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">sort &lt; file_list.txt &gt; sorted_file_list.txt</strong></p><p name="4e34" id="4e34" class="graf graf--p graf-after--p">As we can see, a command can have both its input and output redirected. Be aware that the order of the redirection does not matter. The only requirement is that the redirection operators (the “&lt;” and “&gt;”) must appear after the other options and arguments in the command.</p><p name="fc3a" id="fc3a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Pipelines</strong></p><p name="5268" id="5268" class="graf graf--p graf-after--p">The most useful and powerful thing we can do with I/O redirection is to connect multiple commands together to form what are called <em class="markup--em markup--p-em">pipelines</em>. With pipelines, the standard output of one command is fed into the standard input of another. Here is a very useful example:</p><p name="90a8" id="90a8" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">ls -l | less</strong></p><p name="5723" id="5723" class="graf graf--p graf-after--p">In this example, the output of the <strong class="markup--strong markup--p-strong">ls</strong> command is fed into <strong class="markup--strong markup--p-strong">less</strong>. By using this <strong class="markup--strong markup--p-strong">“| less”</strong> trick, we can make any command have scrolling output.</p><p name="cbdf" id="cbdf" class="graf graf--p graf-after--p">By connecting commands together, we can accomplish amazing feats. Here are some examples to try:</p><p name="ff2f" id="ff2f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Performing tasks with pipelines</strong></p><p name="917d" id="917d" class="graf graf--p graf-after--p">1. <strong class="markup--strong markup--p-strong">Printing from the command line.</strong> Linux provides a program called <a href="http://linuxcommand.org/lc3_man_pages/lpr1.html" data-href="http://linuxcommand.org/lc3_man_pages/lpr1.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">lpr</strong></a> that accepts standard input and sends it to the printer. It is often used with pipes and filters. Here are a couple of examples:</p><p name="b1f6" id="b1f6" class="graf graf--p graf-after--p">cat poorly_formatted_report.txt | fmt | pr | lpr cat unsorted_list_with_dupes.txt | sort | uniq | pr | lpr</p><p name="b8f0" id="b8f0" class="graf graf--p graf-after--p">1. In the first example, we use <strong class="markup--strong markup--p-strong">cat</strong> to read the file and output it to standard output, which is piped into the standard input of <strong class="markup--strong markup--p-strong">fmt. fmt</strong> formats the text into neat paragraphs and outputs it to standard output, which is piped into the standard input of <strong class="markup--strong markup--p-strong">pr. pr</strong> splits the text neatly into pages and outputs it to standard output, which is piped into the standard input of <strong class="markup--strong markup--p-strong">lpr. lpr</strong> takes its standard input and sends it to the printer.</p><p name="a9fc" id="a9fc" class="graf graf--p graf-after--p">2. The second example starts with an unsorted list of data with duplicate entries. First, <strong class="markup--strong markup--p-strong">cat</strong> sends the list into <strong class="markup--strong markup--p-strong">sort</strong> which sorts it and feeds it into <strong class="markup--strong markup--p-strong">uniq</strong> which removes any duplicates. Next <strong class="markup--strong markup--p-strong">pr</strong> and <strong class="markup--strong markup--p-strong">lpr</strong> are used to paginate and print the list.</p><p name="39f9" id="39f9" class="graf graf--p graf-after--p">3. <strong class="markup--strong markup--p-strong">Viewing the contents of tar files</strong> Often you will see software distributed as a <em class="markup--em markup--p-em">gzipped tar file</em>. This is a traditional Unix style tape archive file (created with <a href="http://linuxcommand.org/lc3_man_pages/tar1.html" data-href="http://linuxcommand.org/lc3_man_pages/tar1.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">tar</strong></a>) that has been compressed with <a href="http://linuxcommand.org/lc3_man_pages/gzip1.html" data-href="http://linuxcommand.org/lc3_man_pages/gzip1.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">gzip</strong></a>. You can recognize these files by their traditional file extensions, “.tar.gz” or “.tgz”. You can use the following command to view the directory of such a file on a Linux system:</p><p name="deb0" id="deb0" class="graf graf--p graf-after--p">tar tzvf name_of_file.tar.gz | less</p><p name="f20c" id="f20c" class="graf graf--p graf-after--p">Each time we type a command line and press the enter key, bash performs several processes upon the text before it carries out our command. We have seen a couple of cases of how a simple character sequence, for example “*”, can have a lot of meaning to the shell. The process that makes this happen is called <em class="markup--em markup--p-em">expansion</em>. With expansion, we type something and it is expanded into something else before the shell acts upon it. To demonstrate what we mean by this, let’s take a look at the <a href="http://linuxcommand.org/lc3_man_pages/echoh.html" data-href="http://linuxcommand.org/lc3_man_pages/echoh.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">echo</strong></a> command. <strong class="markup--strong markup--p-strong">echo</strong> is a shell builtin that performs a very simple task. It prints out its text arguments on standard output:</p><p name="c572" id="c572" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo this is a test</strong> this is a test</p><p name="b7db" id="b7db" class="graf graf--p graf-after--p">That’s pretty straightforward. Any argument passed to <strong class="markup--strong markup--p-strong">echo</strong> gets displayed. Let’s try another example:</p><p name="8dc1" id="8dc1" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo *</strong> Desktop Documents ls-output.txt Music Pictures Public Templates Videos</p><p name="3b0c" id="3b0c" class="graf graf--p graf-after--p">So what just happened? Why didn’t <strong class="markup--strong markup--p-strong">echo</strong> print “*”? As we recall from our work with wildcards, the “*” character means match any characters in a filename, but what we didn’t see in our original discussion was how the shell does that. The simple answer is that the shell expands the “*” into something else (in this instance, the names of the files in the current working directory) before the <strong class="markup--strong markup--p-strong">echo</strong> command is executed. When the enter key is pressed, the shell automatically expands any qualifying characters on the command line before the command is carried out, so the <strong class="markup--strong markup--p-strong">echo</strong> command never saw the “*”, only its expanded result. Knowing this, we can see that <strong class="markup--strong markup--p-strong">echo</strong> behaved as expected.</p><p name="4c77" id="4c77" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Pathname Expansion</strong></p><p name="f1f3" id="f1f3" class="graf graf--p graf-after--p">The mechanism by which wildcards work is called <em class="markup--em markup--p-em">pathname expansion</em>. If we try some of the techniques that we employed in our earlier lessons, we will see that they are really expansions. Given a home directory that looks like this:</p><p name="9d41" id="9d41" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">ls</strong> Desktop ls-output.txt Documents Music Pictures Public Templates Videos</p><p name="7efa" id="7efa" class="graf graf--p graf-after--p">we could carry out the following expansions:</p><p name="12c0" id="12c0" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo D*</strong> Desktop Documents</p><p name="36e3" id="36e3" class="graf graf--p graf-after--p">and:</p><p name="49cf" id="49cf" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo *s</strong> Documents Pictures Templates Videos</p><p name="7d40" id="7d40" class="graf graf--p graf-after--p">or even:</p><p name="99e1" id="99e1" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo [[:upper:]]*</strong> Desktop Documents Music Pictures Public Templates Videos</p><p name="201b" id="201b" class="graf graf--p graf-after--p">and looking beyond our home directory:</p><p name="e53a" id="e53a" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo /usr/*/share</strong> /usr/kerberos/share /usr/local/share</p><p name="a5a4" id="a5a4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Tilde Expansion</strong></p><p name="b05c" id="b05c" class="graf graf--p graf-after--p">As we recall from our introduction to the <strong class="markup--strong markup--p-strong">cd</strong> command, the tilde character (“~”) has a special meaning. When used at the beginning of a word, it expands into the name of the home directory of the named user, or if no user is named, the home directory of the current user:</p><p name="f21d" id="f21d" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo ~</strong> /home/me</p><p name="f54a" id="f54a" class="graf graf--p graf-after--p">If user “foo” has an account, then:</p><p name="e472" id="e472" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo ~foo</strong> /home/foo</p><p name="35a7" id="35a7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Arithmetic Expansion</strong></p><p name="81c1" id="81c1" class="graf graf--p graf-after--p">The shell allows arithmetic to be performed by expansion. This allow us to use the shell prompt as a calculator:</p><p name="ab03" id="ab03" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo $((2 + 2))</strong> 4</p><p name="6ed4" id="6ed4" class="graf graf--p graf-after--p">Arithmetic expansion uses the form:</p><p name="d916" id="d916" class="graf graf--p graf-after--p">$((expression))</p><p name="67d3" id="67d3" class="graf graf--p graf-after--p">where expression is an arithmetic expression consisting of values and arithmetic operators.</p><p name="b340" id="b340" class="graf graf--p graf-after--p">Arithmetic expansion only supports integers (whole numbers, no decimals), but can perform quite a number of different operations.</p><p name="ff59" id="ff59" class="graf graf--p graf-after--p">Spaces are not significant in arithmetic expressions and expressions may be nested. For example, to multiply five squared by three:</p><p name="f303" id="f303" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo $(($((5**2)) * 3))</strong> 75</p><p name="f20e" id="f20e" class="graf graf--p graf-after--p">Single parentheses may be used to group multiple subexpressions. With this technique, we can rewrite the example above and get the same result using a single expansion instead of two:</p><p name="6b6a" id="6b6a" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo $(((5**2) * 3))</strong> 75</p><p name="ea45" id="ea45" class="graf graf--p graf-after--p">Here is an example using the division and remainder operators. Notice the effect of integer division:</p><p name="5767" id="5767" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo Five divided by two equals $((5/2))</strong> Five divided by two equals 2 [me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo with $((5%2)) left over.</strong> with 1 left over.</p><p name="64e5" id="64e5" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Brace Expansion</strong></p><p name="2d7e" id="2d7e" class="graf graf--p graf-after--p">Perhaps the strangest expansion is called <em class="markup--em markup--p-em">brace expansion</em>. With it, we can create multiple text strings from a pattern containing braces. Here’s an example:</p><p name="3c72" id="3c72" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo Front-{A,B,C}-Back</strong> Front-A-Back Front-B-Back Front-C-Back</p><p name="3d6f" id="3d6f" class="graf graf--p graf-after--p">Patterns to be brace expanded may contain a leading portion called a <em class="markup--em markup--p-em">preamble</em> and a trailing portion called a <em class="markup--em markup--p-em">postscript</em>. The brace expression itself may contain either a comma-separated list of strings, or a range of integers or single characters. The pattern may not contain embedded whitespace. Here is an example using a range of integers:</p><p name="5748" id="5748" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo Number_{1..5}</strong> Number_1 Number_2 Number_3 Number_4 Number_5</p><p name="fc0b" id="fc0b" class="graf graf--p graf-after--p">A range of letters in reverse order:</p><p name="47cf" id="47cf" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo {Z..A}</strong> Z Y X W V U T S R Q P O N M L K J I H G F E D C B A</p><p name="2b77" id="2b77" class="graf graf--p graf-after--p">Brace expansions may be nested:</p><p name="a23c" id="a23c" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo a{A{1,2},B{3,4}}b</strong> aA1b aA2b aB3b aB4b</p><p name="6982" id="6982" class="graf graf--p graf-after--p">So what is this good for? The most common application is to make lists of files or directories to be created. For example, if we were a photographer and had a large collection of images we wanted to organize into years and months, the first thing we might do is create a series of directories named in numeric “Year-Month” format. This way, the directory names will sort in chronological order. we could type out a complete list of directories, but that’s a lot of work and it’s error-prone too. Instead, we could do this:</p><p name="8064" id="8064" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">mkdir Photos</strong> [me@bgoonz me]$ <strong class="markup--strong markup--p-strong">cd Photos</strong> [me@bgoonz Photos]$ <strong class="markup--strong markup--p-strong">mkdir {2017..2019}-{01..12}</strong> [me@bgoonz Photos]$ <strong class="markup--strong markup--p-strong">ls</strong> 2017–01 2017–07 2018–01 2018–07 2019–01 2019–07 2017–02 2017–08 2018–02 2018–08 2019–02 2019–08 2017–03 2017–09 2018–03 2018–09 2019–03 2019–09 2017–04 2017–10 2018–04 2018–10 2019–04 2019–10 2017–05 2017–11 2018–05 2018–11 2019–05 2019–11 2017–06 2017–12 2018–06 2018–12 2019–06 2019–12</p><p name="d61d" id="d61d" class="graf graf--p graf-after--p">Pretty slick!</p><p name="c340" id="c340" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Parameter Expansion</strong></p><p name="07fa" id="07fa" class="graf graf--p graf-after--p">We’re only going to touch briefly on <em class="markup--em markup--p-em">parameter expansion</em> in this lesson, but we’ll be covering it more later. It’s a feature that is more useful in shell scripts than directly on the command line. Many of its capabilities have to do with the system’s ability to store small chunks of data and to give each chunk a name. Many such chunks, more properly called <em class="markup--em markup--p-em">variables</em>, are available for our examination. For example, the variable named “USER” contains our user name. To invoke parameter expansion and reveal the contents of USER we would do this:</p><p name="b2a5" id="b2a5" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo $USER</strong> me</p><p name="397b" id="397b" class="graf graf--p graf-after--p">To see a list of available variables, try this:</p><p name="fd1d" id="fd1d" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">printenv | less</strong></p><p name="642f" id="642f" class="graf graf--p graf-after--p">With other types of expansion, if we mistype a pattern, the expansion will not take place and the echo command will simply display the mistyped pattern. With parameter expansion, if we misspell the name of a variable, the expansion will still take place, but will result in an empty string:</p><p name="fa93" id="fa93" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo $SUER</strong> [me@bgoonz ~]$</p><p name="c5b3" id="c5b3" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Command Substitution</strong></p><p name="ade3" id="ade3" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Command substitution</em> allows us to use the output of a command as an expansion:</p><p name="363e" id="363e" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo $(ls)</strong> Desktop Documents ls-output.txt Music Pictures Public Templates Videos</p><p name="5d27" id="5d27" class="graf graf--p graf-after--p">A clever one goes something like this:</p><p name="e1a2" id="e1a2" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">ls -l $(which cp)</strong> -rwxr-xr-x 1 root root 71516 2007–12–05 08:58 /bin/cp</p><p name="5471" id="5471" class="graf graf--p graf-after--p">Here we passed the results of <strong class="markup--strong markup--p-strong">which cp</strong> as an argument to the <strong class="markup--strong markup--p-strong">ls</strong> command, thereby getting the listing of of the <strong class="markup--strong markup--p-strong">cp</strong> program without having to know its full pathname. We are not limited to just simple commands. Entire pipelines can be used (only partial output shown):</p><p name="def8" id="def8" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">file $(ls /usr/bin/* | grep bin/zip)</strong> /usr/bin/bunzip2: /usr/bin/zip: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.15, stripped /usr/bin/zipcloak: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.15, stripped /usr/bin/zipgrep: POSIX shell script text executable /usr/bin/zipinfo: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.15, stripped /usr/bin/zipnote: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.15, stripped /usr/bin/zipsplit: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.15, stripped</p><p name="48b6" id="48b6" class="graf graf--p graf-after--p">In this example, the results of the pipeline became the argument list of the file command. There is an alternate syntax for command substitution in older shell programs which is also supported in <strong class="markup--strong markup--p-strong">bash</strong>. It uses back-quotes instead of the dollar sign and parentheses:</p><p name="fb7a" id="fb7a" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">ls -l `which cp`</strong> -rwxr-xr-x 1 root root 71516 2007–12–05 08:58 /bin/cp</p><p name="9463" id="9463" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Quoting</strong></p><p name="e0c7" id="e0c7" class="graf graf--p graf-after--p">Now that we’ve seen how many ways the shell can perform expansions, it’s time to learn how we can control it. Take for example:</p><p name="14d7" id="14d7" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo this is a test</strong> this is a test</p><p name="70e5" id="70e5" class="graf graf--p graf-after--p">or:</p><p name="69d4" id="69d4" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">[me@bgoonz ~]$ echo The total is $100.00</strong> The total is 00.00</p><p name="e727" id="e727" class="graf graf--p graf-after--p">In the first example, word-splitting by the shell removed extra whitespace from the echo command’s list of arguments. In the second example, parameter expansion substituted an empty string for the value of “$1” because it was an undefined variable. The shell provides a mechanism called <em class="markup--em markup--p-em">quoting</em> to selectively suppress unwanted expansions.</p><p name="6506" id="6506" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Double Quotes</strong></p><p name="68d5" id="68d5" class="graf graf--p graf-after--p">The first type of quoting we will look at is double quotes. If we place text inside double quotes, all the special characters used by the shell lose their special meaning and are treated as ordinary characters. The exceptions are “$”, “\” (backslash), and “`” (back- quote). This means that word-splitting, pathname expansion, tilde expansion, and brace expansion are suppressed, but parameter expansion, arithmetic expansion, and command substitution are still carried out. Using double quotes, we can cope with filenames containing embedded spaces. Imagine we were the unfortunate victim of a file called two words.txt. If we tried to use this on the command line, word-splitting would cause this to be treated as two separate arguments rather than the desired single argument:</p><p name="96a6" id="96a6" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">ls -l two words.txt</strong> ls: cannot access two: No such file or directory ls: cannot access words.txt: No such file or directory</p><p name="87a6" id="87a6" class="graf graf--p graf-after--p">By using double quotes, we can stop the word-splitting and get the desired result; further, we can even repair the damage:</p><p name="78e1" id="78e1" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">ls -l “two words.txt”</strong> -rw-rw-r — 1 me me 18 2020–02–20 13:03 two words.txt [me@bgoonz me]$ <strong class="markup--strong markup--p-strong">mv “two words.txt” two_words.txt</strong></p><p name="c915" id="c915" class="graf graf--p graf-after--p">There! Now we don’t have to keep typing those pesky double quotes. Remember, parameter expansion, arithmetic expansion, and command substitution still take place within double quotes:</p><p name="0052" id="0052" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo “$USER $((2+2)) $(cal)”</strong> me 4 February 2020 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29</p><p name="f9e1" id="f9e1" class="graf graf--p graf-after--p">We should take a moment to look at the effect of double quotes on command substitution. First let’s look a little deeper at how word splitting works. In our earlier example, we saw how word-splitting appears to remove extra spaces in our text:</p><p name="c440" id="c440" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo this is a test</strong> this is a test</p><p name="bf02" id="bf02" class="graf graf--p graf-after--p">By default, word-splitting looks for the presence of spaces, tabs, and newlines (linefeed characters) and treats them as delimiters between words. This means that unquoted spaces, tabs, and newlines are not considered to be part of the text. They only serve as separators. Since they separate the words into different arguments, our example command line contains a command followed by four distinct arguments. If we add double quotes:</p><p name="b6d5" id="b6d5" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo “this is a test”</strong> this is a test</p><p name="e57a" id="e57a" class="graf graf--p graf-after--p">word-splitting is suppressed and the embedded spaces are not treated as delimiters, rather they become part of the argument. Once the double quotes are added, our command line contains a command followed by a single argument. The fact that newlines are considered delimiters by the word-splitting mechanism causes an interesting, albeit subtle, effect on command substitution. Consider the following:</p><p name="790d" id="790d" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo $(cal)</strong> February 2020 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 [me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo “$(cal)”</strong> February 2020 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29</p><p name="af1d" id="af1d" class="graf graf--p graf-after--p">In the first instance, the unquoted command substitution resulted in a command line containing thirty-eight arguments. In the second, a command line with one argument that includes the embedded spaces and newlines.</p><p name="0bc1" id="0bc1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Single Quotes</strong></p><p name="9112" id="9112" class="graf graf--p graf-after--p">When we need to suppress all expansions, we use single quotes. Here is a comparison of unquoted, double quotes, and single quotes:</p><p name="81cc" id="81cc" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER</strong> text /home/me/ls-output.txt a b foo 4 me [me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo “text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER”</strong> text ~/*.txt {a,b} foo 4 me [me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo ‘text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER’</strong> text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER</p><p name="f4d7" id="f4d7" class="graf graf--p graf-after--p">As we can see, with each succeeding level of quoting, more and more of the expansions are suppressed.</p><p name="53a3" id="53a3" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Escaping Characters</strong></p><p name="64b2" id="64b2" class="graf graf--p graf-after--p">Sometimes we only want to quote a single character. To do this, we can precede a character with a backslash, which in this context is called the <em class="markup--em markup--p-em">escape character</em>. Often this is done inside double quotes to selectively prevent an expansion:</p><p name="0e8c" id="0e8c" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo “The balance for user $USER is: \$5.00”</strong> The balance for user me is: $5.00</p><p name="7c57" id="7c57" class="graf graf--p graf-after--p">It is also common to use escaping to eliminate the special meaning of a character in a filename. For example, it is possible to use characters in filenames that normally have special meaning to the shell. These would include “$”, “!”, “&amp;”, “ “, and others. To include a special character in a filename we can to this:</p><p name="7336" id="7336" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">mv bad\&amp;filename good_filename</strong></p><p name="f9ef" id="f9ef" class="graf graf--p graf-after--p">To allow a backslash character to appear, escape it by typing “\\”. Note that within single quotes, the backslash loses its special meaning and is treated as an ordinary character.</p><p name="8e4f" id="8e4f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">More Backslash Tricks</strong></p><p name="eff1" id="eff1" class="graf graf--p graf-after--p">If we look at the <strong class="markup--strong markup--p-strong">man</strong> pages for any program written by the <a href="http://www.gnu.org/" data-href="http://www.gnu.org/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">GNU project</a>, we will see that in addition to command line options consisting of a dash and a single letter, there are also long option names that begin with two dashes. For example, the following are equivalent:</p><p name="73d8" id="73d8" class="graf graf--p graf-after--p">ls -r ls — reverse</p><p name="d275" id="d275" class="graf graf--p graf-after--p">Why do they support both? The short form is for lazy typists on the command line and the long form is mostly for scripts though some options may only be available in long form. Sometimes it is better to use a long option when the option is obscure or we want to document more clearly what an option is. This is especially useful when writing scripts where maximum readability is desired, and besides, anytime we can save ourselves a trip to the man page is a good thing.</p><p name="7941" id="7941" class="graf graf--p graf-after--p">As we might suspect, using the long form options can make a single command line very long. To combat this problem, we can use a backslash to get the shell to ignore a newline character like this:</p><p name="110a" id="110a" class="graf graf--p graf-after--p">ls -l \ — reverse \ — human-readable \ — full-time</p><p name="b313" id="b313" class="graf graf--p graf-after--p">Using the backslash in this way allows us to embed newlines in our command. Note that for this trick to work, the newline must be typed immediately after the backslash. If we put a space after the backslash, the space will be ignored, not the newline. Backslashes are also used to insert special characters into our text. These are called <em class="markup--em markup--p-em">backslash escape characters</em>. Here are the common ones:</p><p name="83dc" id="83dc" class="graf graf--p graf-after--p">The use of the backslash escape characters is very common. This idea first appeared in the C programming language. Today, the shell, C++, Perl, python, awk, tcl, and many other programming languages use this concept. Using the <strong class="markup--strong markup--p-strong">echo</strong> command with the -e option will allow us to demonstrate:</p><p name="c50f" id="c50f" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo -e “Inserting several blank lines\n\n\n”</strong> Inserting several blank lines [me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo -e “Words\tseparated\tby\thorizontal\ttabs.”</strong> Words separated by horizontal tabs [me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo -e “\aMy computer went \”beep\”.”</strong> My computer went “beep”. [me@bgoonz me]$ <strong class="markup--strong markup--p-strong">echo -e “DEL C:\\WIN2K\\LEGACY_OS.EXE”</strong> DEL C:\WIN2K\LEGACY_OS.EXE</p><p name="3a9a" id="3a9a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Permissions</strong></p><p name="81e5" id="81e5" class="graf graf--p graf-after--p">The Unix-like operating systems, such as Linux differ from other computing systems in that they are not only <em class="markup--em markup--p-em">multitasking</em> but also <em class="markup--em markup--p-em">multi-user</em>.</p><p name="f1d7" id="f1d7" class="graf graf--p graf-after--p">What exactly does this mean? It means that more than one user can be operating the computer at the same time. While a desktop or laptop computer only has one keyboard and monitor, it can still be used by more than one user. For example, if the computer is attached to a network, or the Internet, remote users can log in via <a href="http://linuxcommand.org/lc3_man_pages/ssh1.html" data-href="http://linuxcommand.org/lc3_man_pages/ssh1.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">ssh</strong></a> (secure shell) and operate the computer. In fact, remote users can execute graphical applications and have the output displayed on a remote computer. The X Window system supports this.</p><p name="07dc" id="07dc" class="graf graf--p graf-after--p">The multi-user capability of Unix-like systems is a feature that is deeply ingrained into the design of the operating system. If we remember the environment in which Unix was created, this makes perfect sense. Years ago before computers were “personal,” they were large, expensive, and centralized. A typical university computer system consisted of a large mainframe computer located in some building on campus and <em class="markup--em markup--p-em">terminals</em> were located throughout the campus, each connected to the large central computer. The computer would support many users at the same time.</p><p name="7c56" id="7c56" class="graf graf--p graf-after--p">In order to make this practical, a method had to be devised to protect the users from each other. After all, we wouldn’t want the actions of one user to crash the computer, nor would we allow one user to interfere with the files belonging to another user.</p><p name="6481" id="6481" class="graf graf--p graf-after--p">This lesson will cover the following commands:</p><ul class="postList"><li name="681f" id="681f" class="graf graf--li graf-after--p"><a href="http://linuxcommand.org/lc3_man_pages/chmod1.html" data-href="http://linuxcommand.org/lc3_man_pages/chmod1.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">chmod</strong></a> — modify file access rights</li><li name="22e9" id="22e9" class="graf graf--li graf-after--li"><a href="http://linuxcommand.org/lc3_man_pages/su1.html" data-href="http://linuxcommand.org/lc3_man_pages/su1.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">su</strong></a> — temporarily become the superuser</li><li name="ca99" id="ca99" class="graf graf--li graf-after--li"><a href="http://linuxcommand.org/lc3_man_pages/sudo8.html" data-href="http://linuxcommand.org/lc3_man_pages/sudo8.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">sudo</strong></a> — temporarily become the superuser</li><li name="b794" id="b794" class="graf graf--li graf-after--li"><a href="http://linuxcommand.org/lc3_man_pages/chown1.html" data-href="http://linuxcommand.org/lc3_man_pages/chown1.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">chown</strong></a> — change file ownership</li><li name="87bd" id="87bd" class="graf graf--li graf-after--li"><a href="http://linuxcommand.org/lc3_man_pages/chgrp1.html" data-href="http://linuxcommand.org/lc3_man_pages/chgrp1.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">chgrp</strong></a> — change a file’s group ownership</li></ul><p name="96e5" id="96e5" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">File Permissions</strong></p><p name="958e" id="958e" class="graf graf--p graf-after--p">On a Linux system, each file and directory is assigned access rights for the owner of the file, the members of a group of related users, and everybody else. Rights can be assigned to read a file, to write a file, and to execute a file (i.e., run the file as a program).</p><p name="c7cb" id="c7cb" class="graf graf--p graf-after--p">To see the permission settings for a file, we can use the <strong class="markup--strong markup--p-strong">ls</strong> command. As an example, we will look at the <strong class="markup--strong markup--p-strong">bash</strong> program which is located in the /bin directory:</p><p name="b275" id="b275" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">ls -l /bin/bash</strong> -rwxr-xr-x 1 root root 1113504 Jun 6 2019 /bin/bash</p><p name="135d" id="135d" class="graf graf--p graf-after--p">Here we can see:</p><ul class="postList"><li name="c022" id="c022" class="graf graf--li graf-after--p">The file “/bin/bash” is owned by user “root”</li><li name="3508" id="3508" class="graf graf--li graf-after--li">The superuser has the right to read, write, and execute this file</li><li name="7354" id="7354" class="graf graf--li graf-after--li">The file is owned by the group “root”</li><li name="8400" id="8400" class="graf graf--li graf-after--li">Members of the group “root” can also read and execute this file</li><li name="2ccd" id="2ccd" class="graf graf--li graf-after--li">Everybody else can read and execute this file</li></ul><p name="5b98" id="5b98" class="graf graf--p graf-after--li">In the diagram below, we see how the first portion of the listing is interpreted. It consists of a character indicating the file type, followed by three sets of three characters that convey the reading, writing and execution permission for the owner, group, and everybody else.</p><p name="6c77" id="6c77" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">chmod</strong></p><p name="283f" id="283f" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">chmod</strong> command is used to change the permissions of a file or directory. To use it, we specify the desired permission settings and the file or files that we wish to modify. There are two ways to specify the permissions. In this lesson we will focus on one of these, called the <em class="markup--em markup--p-em">octal notation</em> method.</p><p name="79c2" id="79c2" class="graf graf--p graf-after--p">It is easy to think of the permission settings as a series of bits (which is how the computer thinks about them). Here’s how it works:</p><p name="2c39" id="2c39" class="graf graf--p graf-after--p">rwx rwx rwx = 111 111 111<br> rw- rw- rw- = 110 110 110<br> rwx — — — — = 111 000 000</p><p name="7e55" id="7e55" class="graf graf--p graf-after--p">and so on…</p><p name="633b" id="633b" class="graf graf--p graf-after--p">rwx = 111 in binary = 7<br> rw- = 110 in binary = 6<br> r-x = 101 in binary = 5<br> r — = 100 in binary = 4</p><p name="3ebc" id="3ebc" class="graf graf--p graf-after--p">Now, if we represent each of the three sets of permissions (owner, group, and other) as a single digit, we have a pretty convenient way of expressing the possible permissions settings. For example, if we wanted to set some_file to have read and write permission for the owner, but wanted to keep the file private from others, we would:</p><p name="5c11" id="5c11" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">chmod 600 some_file</strong></p><p name="1249" id="1249" class="graf graf--p graf-after--p">Here is a table of numbers that covers all the common settings. The ones beginning with “7” are used with programs (since they enable execution) and the rest are for other kinds of files.</p><p name="f30a" id="f30a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Becoming the Superuser for a Short While</strong></p><p name="1086" id="1086" class="graf graf--p graf-after--p">It is often necessary to become the superuser to perform important system administration tasks, but as we know, we should not stay logged in as the superuser. In most distributions, there is a program that can give you temporary access to the superuser’s privileges. This program is called <strong class="markup--strong markup--p-strong">su</strong> (short for substitute user) and can be used in those cases when you need to be the superuser for a small number of tasks. To become the superuser, simply type the <strong class="markup--strong markup--p-strong">su</strong> command. You will be prompted for the superuser’s password:</p><p name="a4a3" id="a4a3" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">su</strong> Password: [root@bgoonz me]#</p><p name="9050" id="9050" class="graf graf--p graf-after--p">After executing the <strong class="markup--strong markup--p-strong">su</strong> command, we have a new shell session as the superuser. To exit the superuser session, type <strong class="markup--strong markup--p-strong">exit</strong> and we will return to your previous session.</p><p name="31b7" id="31b7" class="graf graf--p graf-after--p">In most modern distributions, an alternate method is used. Rather than using <strong class="markup--strong markup--p-strong">su</strong>, these systems employ the <strong class="markup--strong markup--p-strong">sudo</strong> command instead. With <strong class="markup--strong markup--p-strong">sudo</strong>, one or more users are granted superuser privileges on an as needed basis. To execute a command as the superuser, the desired command is simply preceded with the <strong class="markup--strong markup--p-strong">sudo</strong> command. After the command is entered, the user is prompted for the their own password rather than the superuser’s:</p><p name="90c2" id="90c2" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">sudo some_command</strong> Password for me: [me@bgoonz me]$</p><p name="7493" id="7493" class="graf graf--p graf-after--p">In fact, modern distributions don’t even set the root account password thus making it impossible to log in as the root user. A root shell is still possible with <strong class="markup--strong markup--p-strong">sudo</strong> by using the “-i” option:</p><p name="45ff" id="45ff" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">sudo -i</strong> Password for me: root@bgoonz:~#</p><p name="a615" id="a615" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Changing File Ownership</strong></p><p name="e56e" id="e56e" class="graf graf--p graf-after--p">We can change the owner of a file by using the <strong class="markup--strong markup--p-strong">chown</strong> command. Here’s an example: Suppose we wanted to change the owner of some_file from “me” to “you”. We could:</p><p name="687e" id="687e" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">sudo chown you some_file</strong></p><p name="1232" id="1232" class="graf graf--p graf-after--p">Notice that in order to change the owner of a file, we must have superuser privileges. To do this, our example employed the <strong class="markup--strong markup--p-strong">sudo</strong> command to execute <strong class="markup--strong markup--p-strong">chown</strong>.</p><p name="2697" id="2697" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">chown</strong> works the same way on directories as it does on files.</p><p name="caaf" id="caaf" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Changing Group Ownership</strong></p><p name="d054" id="d054" class="graf graf--p graf-after--p">The group ownership of a file or directory may be changed with <strong class="markup--strong markup--p-strong">chgrp</strong>. This command is used like this:</p><p name="1e75" id="1e75" class="graf graf--p graf-after--p">[me@bgoonz me]$ <strong class="markup--strong markup--p-strong">chgrp new_group some_file</strong></p><p name="257d" id="257d" class="graf graf--p graf-after--p">In the example above, we changed the group ownership of some_file from its previous group to “new_group”. We must be the owner of the file or directory to perform a <strong class="markup--strong markup--p-strong">chgrp</strong>.</p><h3 name="fb0c" id="fb0c" class="graf graf--h3 graf-after--p">Writing Scripts:</h3><p name="6b73" id="6b73" class="graf graf--p graf--empty graf-after--h3"><br></p><h3 name="e7f8" id="e7f8" class="graf graf--h3 graf-after--p">Writing Your First Script!</h3><p name="0558" id="0558" class="graf graf--p graf--empty graf-after--h3"><br></p><p name="4bf0" id="4bf0" class="graf graf--p graf-after--p">To successfully write a shell script, we have to do three things:</p><ol class="postList"><li name="4b2a" id="4b2a" class="graf graf--li graf-after--p">Write a script</li><li name="9e12" id="9e12" class="graf graf--li graf-after--li">Give the shell permission to execute it</li><li name="4768" id="4768" class="graf graf--li graf-after--li">Put it somewhere the shell can find it</li></ol><h3 name="807b" id="807b" class="graf graf--h3 graf-after--li">Writing a Script</h3><p name="3a55" id="3a55" class="graf graf--p graf-after--h3">A shell script is a file that contains ASCII text. To create a shell script, we use a <em class="markup--em markup--p-em">text editor</em>. A text editor is a program, like a word processor, that reads and writes ASCII text files. There are many, many text editors available for Linux systems, both for the command line and GUI environments. Here is a list of some common ones:</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="8835" id="8835" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><img class="graf-image" data-image-id="1*hkhhUZbaqqg2zO9DvyyRjA.png" data-width="1411" data-height="266" src="https://cdn-images-1.medium.com/max/1200/1*hkhhUZbaqqg2zO9DvyyRjA.png"></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="548d" id="548d" class="graf graf--p graf--empty graf-after--figure"><br></p><p name="bb5e" id="bb5e" class="graf graf--p graf-after--p">Let’s fire up our text editor and type in our first script as follows:</p><p name="d103" id="d103" class="graf graf--p graf-after--p">#!/bin/bash # My first script echo “Hello World!”</p><p name="48b9" id="48b9" class="graf graf--p graf-after--p">Clever readers will have figured out how to copy and paste the text into the text editor ;-)</p><p name="5579" id="5579" class="graf graf--p graf-after--p">This is a traditional “Hello World” program. Forms of this program appear in almost introductory programming book. We’ll save the file with some descriptive name. How about <code class="markup--code markup--p-code">hello_world</code>?</p><p name="f5b2" id="f5b2" class="graf graf--p graf-after--p">The first line of the script is important. It is a special construct, called a <em class="markup--em markup--p-em">shebang</em>, given to the system indicating what program is to be used to interpret the script. In this case, <code class="markup--code markup--p-code">/bin/bash</code>. Other scripting languages such as <code class="markup--code markup--p-code">Perl, awk, tcl, Tk,</code> and <code class="markup--code markup--p-code">python</code> also use this mechanism.</p><p name="dd77" id="dd77" class="graf graf--p graf-after--p">The second line is a <em class="markup--em markup--p-em">comment</em>. Everything that appears after a “#” symbol is ignored by <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">bash</strong></code>. As our scripts become bigger and more complicated, comments become vital. They are used by programmers to explain what is going on so that others can figure it out. The last line is the <code class="markup--code markup--p-code"><a href="http://linuxcommand.org/lc3_man_pages/echo1.html" data-href="http://linuxcommand.org/lc3_man_pages/echo1.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">echo</strong></a></code> command. This command simply prints its arguments on the display.</p><h3 name="07eb" id="07eb" class="graf graf--h3 graf-after--p">Setting Permissions</h3><p name="9936" id="9936" class="graf graf--p graf-after--h3">The next thing we have to do is give the shell permission to execute our script. This is done with the <code class="markup--code markup--p-code"><a href="http://linuxcommand.org/lc3_man_pages/chmod1.html" data-href="http://linuxcommand.org/lc3_man_pages/chmod1.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">chmod</strong></a></code> command as follows:</p><p name="aadc" id="aadc" class="graf graf--p graf-after--p">[me@linuxbox me]$ <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">chmod 755 hello_world</strong></code></p><p name="a52e" id="a52e" class="graf graf--p graf-after--p">The “755” will give us read, write, and execute permission. Everybody else will get only read and execute permission. To make the script private, (i.e., only we can read and execute), use “700” instead.</p><h3 name="d94e" id="d94e" class="graf graf--h3 graf-after--p">Putting It in Our Path</h3><p name="ecd4" id="ecd4" class="graf graf--p graf-after--h3">At this point, our script will run. Try this:</p><p name="d065" id="d065" class="graf graf--p graf-after--p">[me@linuxbox me]$ <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">./hello_world</strong></code></p><p name="4422" id="4422" class="graf graf--p graf-after--p">We should see “Hello World!” displayed.</p><p name="3b97" id="3b97" class="graf graf--p graf-after--p">Before we go any further, we need to talk about paths. When we type the name of a command, the system does not search the entire computer to find where the program is located. That would take a long time. We see that we don’t usually have to specify a complete path name to the program we want to run, the shell just seems to know.</p><p name="fae1" id="fae1" class="graf graf--p graf-after--p">Well, that’s correct. The shell does know. Here’s how: the shell maintains a list of directories where executable files (programs) are kept, and only searches the directories on that list. If it does not find the program after searching each directory on the list, it will issue the famous <code class="markup--code markup--p-code">command not found</code> error message.</p><p name="4efd" id="4efd" class="graf graf--p graf-after--p">This list of directories is called our <em class="markup--em markup--p-em">path</em>. We can view the list of directories with the following command:</p><p name="4a47" id="4a47" class="graf graf--p graf-after--p">[me@linuxbox me]$ <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">echo $PATH</strong></code></p><p name="9330" id="9330" class="graf graf--p graf-after--p">This will return a colon separated list of directories that will be searched if a specific path name is not given when a command is entered. In our first attempt to execute our new script, we specified a pathname (“./”) to the file.</p><p name="0722" id="0722" class="graf graf--p graf-after--p">We can add directories to our path with the following command, where <em class="markup--em markup--p-em">directory</em> is the name of the directory we want to add:</p><p name="b8da" id="b8da" class="graf graf--p graf-after--p">[me@linuxbox me]$ <code class="markup--code markup--p-code u-paddingRight0 u-marginRight0"><strong class="markup--strong markup--p-strong">export PATH=$PATH:<em class="markup--em markup--p-em">directory</em></strong></code></p><p name="5076" id="5076" class="graf graf--p graf-after--p">A better way would be to edit our <code class="markup--code markup--p-code">.bash_profile</code> file to include the above command. That way, it would be done automatically every time we log in.</p><p name="dd5d" id="dd5d" class="graf graf--p graf-after--p">Most Linux distributions encourage a practice in which each user has a specific directory for the programs he/she personally uses. This directory is called <code class="markup--code markup--p-code">bin</code> and is a subdirectory of our home directory. If we do not already have one, we can create it with the following command:</p><p name="8fdc" id="8fdc" class="graf graf--p graf-after--p">[me@linuxbox me]$ <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">mkdir ~/bin</strong></code></p><p name="48c1" id="48c1" class="graf graf--p graf-after--p">If we move our script into our new <code class="markup--code markup--p-code">bin</code> directory we&#39;ll be all set. Now we just have to type:</p><p name="37ac" id="37ac" class="graf graf--p graf-after--p">[me@linuxbox me]$ <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">hello_world</strong></code></p><p name="cb6d" id="cb6d" class="graf graf--p graf-after--p">and our script will run. On some distributions, most notably Ubuntu (and other Debian-based distributions), we will need to open a new terminal session before our newly created <code class="markup--code markup--p-code">bin</code> directory will be recognized.</p><h3 name="0609" id="0609" class="graf graf--h3 graf-after--p">Editing the Scripts We Already Have</h3><p name="bed2" id="bed2" class="graf graf--p graf-after--h3">Before we start writing new scripts, We’ll take a look at some scripts we already have. These scripts were put into our home directory when our account was created, and are used to configure the behavior of our sessions on the computer. We can edit these scripts to change things.</p><p name="6fc2" id="6fc2" class="graf graf--p graf-after--p">In this lesson, we will look at a couple of these scripts and learn a few important new concepts about the shell.</p><p name="1c0d" id="1c0d" class="graf graf--p graf-after--p">During our shell session, the system is holding a number of facts about the world in its memory. This information is called the <em class="markup--em markup--p-em">environment</em>. The environment contains such things as our path, our user name, and much more. We can examine a complete list of what is in the environment with the <code class="markup--code markup--p-code"><a href="http://linuxcommand.org/lc3_man_pages/seth.html" data-href="http://linuxcommand.org/lc3_man_pages/seth.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">set</strong></a></code> command.</p><p name="5a9b" id="5a9b" class="graf graf--p graf-after--p">Two types of commands are often contained in the environment. They are <em class="markup--em markup--p-em">aliases</em> and <em class="markup--em markup--p-em">shell functions</em>.</p><h3 name="1997" id="1997" class="graf graf--h3 graf-after--p">How is the Environment Established?</h3><p name="5671" id="5671" class="graf graf--p graf-after--h3">When we log on to the system, the bash program starts, and reads a series of configuration scripts called <em class="markup--em markup--p-em">startup files</em>. These define the default environment shared by all users. This is followed by more startup files in our home directory that define our personal environment. The exact sequence depends on the type of shell session being started. There are two kinds: a <em class="markup--em markup--p-em">login shell session</em> and a <em class="markup--em markup--p-em">non-login shell session</em>. A login shell session is one in which we are prompted for our user name and password; when we start a virtual console session, for example. A non-login shell session typically occurs when we launch a terminal session in the GUI.</p><p name="174f" id="174f" class="graf graf--p graf-after--p">Login shells read one or more startup files as shown below:</p><figure name="d4b0" id="d4b0" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*0wWeUUHV2zMfEDeXTgh7MQ.png" data-width="1070" data-height="346" src="https://cdn-images-1.medium.com/max/800/1*0wWeUUHV2zMfEDeXTgh7MQ.png"></figure><p name="096b" id="096b" class="graf graf--p graf-after--figure">In addition to reading the startup files above, non-login shells also inherit the environment from their parent process, usually a login shell.</p><p name="3d17" id="3d17" class="graf graf--p graf-after--p">Take a look at your system and see which of these startup files you have. Remember — since most of the file names listed above start with a period (meaning that they are hidden), you will need to use the “-a” option when using ls.</p><p name="92b3" id="92b3" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">~/.bashrc</code> file is probably the most important startup file from the ordinary user’s point of view, since it is almost always read. Non-login shells read it by default and most startup files for login shells are written in such a way as to read the <code class="markup--code markup--p-code">~/.bashrc</code> file as well.</p><p name="b00e" id="b00e" class="graf graf--p graf-after--p">If we take a look inside a typical <code class="markup--code markup--p-code">.bash_profile</code> (this one taken from a CentOS system), it looks something like this:</p><p name="5f94" id="5f94" class="graf graf--p graf-after--p"># .bash_profile # Get the aliases and functions if [ -f ~/.bashrc ]; then . ~/.bashrc fi # User specific environment and startup programs PATH=$PATH:$HOME/bin export PATH</p><p name="3590" id="3590" class="graf graf--p graf-after--p">Lines that begin with a “#” are comments and are not read by the shell. These are there for human readability. The first interesting thing occurs on the fourth line, with the following code:</p><p name="f7ba" id="f7ba" class="graf graf--p graf-after--p">if [ -f ~/.bashrc ]; then . ~/.bashrc fi</p><p name="ccf6" id="ccf6" class="graf graf--p graf-after--p">This is called an <em class="markup--em markup--p-em">if compound command</em>, which we will cover fully in a later lesson, but for now we will translate:</p><p name="a3a0" id="a3a0" class="graf graf--p graf-after--p">If the file “~/.bashrc” exists, then read the “~/.bashrc” file.</p><p name="4ea3" id="4ea3" class="graf graf--p graf-after--p">We can see that this bit of code is how a login shell gets the contents of <code class="markup--code markup--p-code">.bashrc</code>. The next thing in our startup file does is set the PATH variable to add the <code class="markup--code markup--p-code">~/bin</code> directory to the path.</p><p name="a3aa" id="a3aa" class="graf graf--p graf-after--p">Lastly, we have:</p><p name="d482" id="d482" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">export PATH</code></p><p name="fc23" id="fc23" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code"><a href="http://linuxcommand.org/lc3_man_pages/exporth.html" data-href="http://linuxcommand.org/lc3_man_pages/exporth.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">export</strong></a></code> command tells the shell to make the contents of the PATH variable available to child processes of this shell.</p><h3 name="0435" id="0435" class="graf graf--h3 graf-after--p">Aliases</h3><p name="6918" id="6918" class="graf graf--p graf-after--h3">An alias is an easy way to create a new command which acts as an abbreviation for a longer one. It has the following syntax:</p><p name="1465" id="1465" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code u-paddingRight0 u-marginRight0">alias <em class="markup--em markup--p-em">name</em>=<em class="markup--em markup--p-em">value</em></code></p><p name="2166" id="2166" class="graf graf--p graf-after--p">where <em class="markup--em markup--p-em">name</em> is the name of the new command and <em class="markup--em markup--p-em">value</em> is the text to be executed whenever <em class="markup--em markup--p-em">name</em> is entered on the command line.</p><p name="2106" id="2106" class="graf graf--p graf-after--p">Let’s create an alias called “l” and make it an abbreviation for the command “ls -l”. We’ll move to our home directory and using our favorite text editor, open the file <code class="markup--code markup--p-code">.bashrc</code> and add this line to the end of the file:</p><p name="00ef" id="00ef" class="graf graf--p graf-after--p">alias l=’ls -l’</p><p name="c41b" id="c41b" class="graf graf--p graf-after--p">By adding the <code class="markup--code markup--p-code"><a href="http://linuxcommand.org/lc3_man_pages/aliash.html" data-href="http://linuxcommand.org/lc3_man_pages/aliash.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">alias</strong></a></code> command to the file, we have created a new command called &quot;l&quot; which will perform &quot;ls -l&quot;. To try out our new command, close the terminal session and start a new one. This will reload the <code class="markup--code markup--p-code">.bashrc</code> file. Using this technique, we can create any number of custom commands for ourselves. Here is another one to try:</p><p name="6b1d" id="6b1d" class="graf graf--p graf-after--p">alias today=’date +”%A, %B %-d, %Y”’</p><p name="2ebf" id="2ebf" class="graf graf--p graf-after--p">This alias creates a new command called “today” that will display today’s date with nice formatting.</p><p name="27d2" id="27d2" class="graf graf--p graf-after--p">By the way, the <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">alias</strong></code> command is just another shell builtin. We can create our aliases directly at the command prompt; however they will only remain in effect during the current shell session. For example:</p><p name="5aa2" id="5aa2" class="graf graf--p graf-after--p">[me@linuxbox me]$ <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">alias l=&#39;ls -l&#39;</strong></code></p><h3 name="45f8" id="45f8" class="graf graf--h3 graf-after--p">Shell Functions</h3><p name="c2ba" id="c2ba" class="graf graf--p graf-after--h3">Aliases are good for very simple commands, but to create something more complex, we need <em class="markup--em markup--p-em">shell functions</em>. Shell functions can be thought of as “scripts within scripts” or little sub-scripts. Let’s try one. Open <code class="markup--code markup--p-code">.bashrc</code> with our text editor again and replace the alias for &quot;today&quot; with the following:</p><p name="1938" id="1938" class="graf graf--p graf-after--p">today() { echo -n “Today’s date is: “ date +”%A, %B %-d, %Y” }</p><p name="5131" id="5131" class="graf graf--p graf-after--p">Believe it or not, <code class="markup--code markup--p-code"><a href="http://linuxcommand.org/lc3_man_pages/functionh.html" data-href="http://linuxcommand.org/lc3_man_pages/functionh.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">()</strong></a></code> is a shell builtin too, and as with <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">alias</strong></code>, we can enter shell functions directly at the command prompt.</p><p name="a79c" id="a79c" class="graf graf--p graf-after--p">[me@linuxbox me]$ <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">today() {</strong></code> &gt; <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">echo -n &quot;Today&#39;s date is: &quot;</strong></code> &gt; <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">date +&quot;%A, %B %-d, %Y&quot;</strong></code> &gt; <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">}</strong></code> [me@linuxbox me]$</p><p name="aef1" id="aef1" class="graf graf--p graf-after--p">However, like <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">alias</strong></code>, shell functions defined directly on the command line only last as long as the current shell session.</p><p name="53fb" id="53fb" class="graf graf--p graf--empty graf-after--p"><br></p><p name="fc36" id="fc36" class="graf graf--p graf--empty graf-after--p"><br></p><h3 name="4838" id="4838" class="graf graf--h3 graf-after--p">Here Scripts</h3><p name="8c9a" id="8c9a" class="graf graf--p graf-after--h3">Beginning with this lesson, we will construct a useful application. This application will produce an HTML document that contains information about our system. As we construct our script, we will discover step by step the tools needed to solve the problem at hand.</p><h3 name="cef3" id="cef3" class="graf graf--h3 graf-after--p">Writing an HTML File with a Script</h3><p name="a027" id="a027" class="graf graf--p graf-after--h3">As we may be aware, a well formed HTML file contains the following content:</p><p name="e83b" id="e83b" class="graf graf--p graf--empty graf-after--p"><br></p><pre name="68e1" id="68e1" class="graf graf--pre graf-after--p">&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;<br>    The title of your page<br>    &lt;/title&gt;<br>&lt;/head&gt;</pre><pre name="7c6a" id="7c6a" class="graf graf--pre graf-after--pre">&lt;body&gt;<br>    Your page content goes here.<br>&lt;/body&gt;<br>&lt;/html&gt;</pre><p name="e527" id="e527" class="graf graf--p graf--empty graf-after--pre"><br></p><p name="c0f9" id="c0f9" class="graf graf--p graf-after--p">Now, with what we already know, we could write a script to produce the above content:</p><pre name="45e1" id="45e1" class="graf graf--pre graf-after--p">#!/bin/bash</pre><pre name="98f3" id="98f3" class="graf graf--pre graf-after--pre"># sysinfo_page - A script to produce an html file</pre><pre name="5bc5" id="5bc5" class="graf graf--pre graf-after--pre">echo &quot;&lt;html&gt;&quot;<br>echo &quot;&lt;head&gt;&quot;<br>echo &quot;  &lt;title&gt;&quot;<br>echo &quot;  The title of your page&quot;<br>echo &quot;  &lt;/title&gt;&quot;<br>echo &quot;&lt;/head&gt;&quot;<br>echo &quot;&quot;<br>echo &quot;&lt;body&gt;&quot;<br>echo &quot;  Your page content goes here.&quot;<br>echo &quot;&lt;/body&gt;&quot;<br>echo &quot;&lt;/html&gt;&quot;</pre><p name="3507" id="3507" class="graf graf--p graf--empty graf-after--pre"><br></p><p name="0743" id="0743" class="graf graf--p graf-after--p">This script can be used as follows:</p><p name="5ed5" id="5ed5" class="graf graf--p graf-after--p">[me@linuxbox me]$ <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">sysinfo_page &gt; sysinfo_page.html</strong></code></p><p name="8204" id="8204" class="graf graf--p graf-after--p">It has been said that the greatest programmers are also the laziest. They write programs to save themselves work. Likewise, when clever programmers write programs, they try to save themselves typing.</p><p name="f793" id="f793" class="graf graf--p graf-after--p">The first improvement to this script will be to replace the repeated use of the <code class="markup--code markup--p-code">echo</code> command with a single instance by using quotation more efficiently:</p><pre name="4f5b" id="4f5b" class="graf graf--pre graf-after--p">#!/bin/bash</pre><pre name="2967" id="2967" class="graf graf--pre graf-after--pre"># sysinfo_page - A script to produce an HTML file</pre><pre name="2440" id="2440" class="graf graf--pre graf-after--pre">echo &quot;&lt;html&gt;<br> &lt;head&gt;<br>   &lt;title&gt;<br>   The title of your page<br>   &lt;/title&gt;<br> &lt;/head&gt;<br> <br> &lt;body&gt;<br>   Your page content goes here.<br> &lt;/body&gt;<br> &lt;/html&gt;&quot;</pre><p name="af4d" id="af4d" class="graf graf--p graf-after--pre">Using quotation, it is possible to embed carriage returns in our text and have the <code class="markup--code markup--p-code">echo</code> command&#39;s argument span multiple lines.</p><p name="6082" id="6082" class="graf graf--p graf-after--p">While this is certainly an improvement, it does have a limitation. Since many types of markup used in HTML incorporate quotation marks themselves, it makes using a quoted string a little awkward. A quoted string can be used but each embedded quotation mark will need to be escaped with a backslash character.</p><p name="85a9" id="85a9" class="graf graf--p graf-after--p">In order to avoid the additional typing, we need to look for a better way to produce our text. Fortunately, the shell provides one. It’s called a <em class="markup--em markup--p-em">here script</em>.</p><pre name="c490" id="c490" class="graf graf--pre graf-after--p">#!/bin/bash</pre><pre name="2e61" id="2e61" class="graf graf--pre graf-after--pre"># sysinfo_page - A script to produce an HTML file</pre><pre name="36cc" id="36cc" class="graf graf--pre graf-after--pre">cat &lt;&lt; _EOF_<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;<br>    The title of your page<br>    &lt;/title&gt;<br>&lt;/head&gt;</pre><pre name="404e" id="404e" class="graf graf--pre graf-after--pre">&lt;body&gt;<br>    Your page content goes here.<br>&lt;/body&gt;<br>&lt;/html&gt;<br>_EOF_</pre><p name="2ad0" id="2ad0" class="graf graf--p graf-after--pre">A here script (also sometimes called a here document) is an additional form of <a href="http://linuxcommand.org/lc3_lts0070.php" data-href="http://linuxcommand.org/lc3_lts0070.php" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">I/O redirection</a>. It provides a way to include content that will be given to the standard input of a command. In the case of the script above, the standard input of the <code class="markup--code markup--p-code">cat</code> command was given a stream of text from our script.</p><p name="938a" id="938a" class="graf graf--p graf-after--p">A here script is constructed like this:</p><p name="cabe" id="cabe" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">command</strong></code> &lt;&lt; token content to be used as command&#39;s standard input token</p><p name="1113" id="1113" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">token</em> can be any string of characters. “_EOF_” (EOF is short for “End Of File”) is traditional, but we can use anything as long as it does not conflict with a bash reserved word. The token that ends the here script must exactly match the one that starts it, or else the remainder of our script will be interpreted as more standard input to the command which can lead to some really exciting script failures.</p><p name="0e77" id="0e77" class="graf graf--p graf-after--p">There is one additional trick that can be used with a here script. Often, we might want to indent the content portion of the here script to improve the readability of the script. We can do this if we change the script as follows:</p><pre name="7a35" id="7a35" class="graf graf--pre graf-after--p">#!/bin/bash</pre><pre name="e13a" id="e13a" class="graf graf--pre graf-after--pre"># sysinfo_page - A script to produce an HTML file</pre><pre name="42b4" id="42b4" class="graf graf--pre graf-after--pre">cat &lt;&lt;- _EOF_<br>    &lt;html&gt;<br>    &lt;head&gt;<br>        &lt;title&gt;<br>        The title of your page<br>        &lt;/title&gt;<br>    &lt;/head&gt;</pre><pre name="d1e4" id="d1e4" class="graf graf--pre graf-after--pre">&lt;body&gt;<br>        Your page content goes here.<br>    &lt;/body&gt;<br>    &lt;/html&gt;<br>_EOF_</pre><p name="c1df" id="c1df" class="graf graf--p graf-after--pre">Changing the “&lt;&lt;” to “&lt;&lt;-” causes bash to ignore the leading tabs (but not spaces) in the here script. The output from the cat command will not contain any of the leading tab characters. This technique is a bit problematic, as many text editors are configured (and desirably so) to use sequences of spaces rather than tab characters.</p><p name="b2f2" id="b2f2" class="graf graf--p graf-after--p">O.k., let’s make our page. We will edit our page to get it to say something:</p><pre name="8b3f" id="8b3f" class="graf graf--pre graf-after--p">#!/bin/bash</pre><pre name="9f67" id="9f67" class="graf graf--pre graf-after--pre"># sysinfo_page - A script to produce an HTML file</pre><pre name="a99a" id="a99a" class="graf graf--pre graf-after--pre">cat &lt;&lt;- _EOF_<br>    &lt;html&gt;<br>    &lt;head&gt;<br>        &lt;title&gt;<br>        My System Information<br>        &lt;/title&gt;<br>    &lt;/head&gt;</pre><pre name="6cfd" id="6cfd" class="graf graf--pre graf-after--pre">&lt;body&gt;<br>    &lt;h1&gt;My System Information&lt;/h1&gt;<br>    &lt;/body&gt;<br>    &lt;/html&gt;<br>_EOF_</pre><p name="4537" id="4537" class="graf graf--p graf--empty graf-after--pre graf--trailing"><br></p></div></div></section>
</section>
<footer><p><a href="https://medium.com/p/8a831acc3def">View original.</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 14, 2021.</p></footer></article></body></html>
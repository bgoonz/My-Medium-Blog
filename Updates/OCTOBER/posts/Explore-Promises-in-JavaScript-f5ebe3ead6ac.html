<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Explore Promises in JavaScript</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bgoonz/GIT-CDN-FILES/mdn-article.css"></head><body><article class="h-entry">
<header>
<h1 class="p-name">Explore Promises in JavaScript</h1>
</header>
<section data-field="subtitle" class="p-summary">
A detailed guide to how promises work in JavaScript
</section>
<section data-field="body" class="e-content">
<section name="af07" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="7f99" id="7f99" class="graf graf--h3 graf--leading graf--title">Explore Promises in JavaScript</h3><h4 name="a33f" id="a33f" class="graf graf--h4 graf-after--h3 graf--subtitle">A detailed guide to how promises work in JavaScript</h4><p name="01bc" id="01bc" class="graf graf--p graf-after--h4">Create a new folder with a JavaScript file within it (such as promises.js).</p><figure name="d9b1" id="d9b1" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*0QVccF8HPXHZCtwR" data-width="880" data-height="495" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*0QVccF8HPXHZCtwR"></figure><h3 name="17ec" id="17ec" class="graf graf--h3 graf-after--figure">Background:</h3><figure name="bf09" id="bf09" class="graf graf--figure graf--iframe graf-after--h3"><script src="https://gist.github.com/bgoonz/548acfe2b167a102b54eb591e7d6a825.js"></script></figure><h3 name="e722" id="e722" class="graf graf--h3 graf-after--figure">Practice Project</h3><h3 name="0e17" id="0e17" class="graf graf--h3 graf-after--h3">Phase 1:¬†<code class="markup--code markup--h3-code">async</code></h3><p name="59c3" id="59c3" class="graf graf--p graf-after--h3">In your file, create two similar functions. Each can return a number or string. Before the second function, place the <code class="markup--code markup--p-code">async</code> keyword. Use the console to log the calls to both functions.</p><pre name="0939" id="0939" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">function num1() {<br>    return 1;<br>}<br>async function num2() {<br>    return 2;<br>}</code></pre><pre name="6dfc" id="6dfc" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">console.log(&#39;num1&#39;, num1());<br>console.log(&#39;num2&#39;, num2());</code></pre><p name="cb6a" id="cb6a" class="graf graf--p graf-after--pre">When you run your program (<code class="markup--code markup--p-code">node promises.js</code> ), you should see something like this:</p><pre name="4884" id="4884" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">num1 1<br>num2 Promise { 2 }</code></pre><p name="0067" id="0067" class="graf graf--p graf-after--pre">Notice that the ‚Äúplain‚Äù function just returns the value and the ‚Äúasync‚Äù function returns a promise. Now add another call to the <code class="markup--code markup--p-code">async</code> function and attach the <code class="markup--code markup--p-code">then</code> function to get its result and log it.</p><pre name="3966" id="3966" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">num2().then(result =&gt; console.log(result));</code></pre><p name="dedd" id="dedd" class="graf graf--p graf-after--pre">Run your program again and now you will see the plain number returned from the second function.</p><blockquote name="10af" id="10af" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">What have you learned so far?</em></blockquote><p name="8090" id="8090" class="graf graf--p graf-after--blockquote">Whenever the <code class="markup--code markup--p-code">async</code> keyword is used, the function automatically returns a promise. Wow!</p><h3 name="da54" id="da54" class="graf graf--h3 graf-after--p">Phase 2:¬†<code class="markup--code markup--h3-code">await</code></h3><p name="8e51" id="8e51" class="graf graf--p graf-after--h3">Next, another <code class="markup--code markup--p-code">async</code> function. Declare a constant that <code class="markup--code markup--p-code">await</code> s the call to your other <code class="markup--code markup--p-code">async</code> function and logs the value. Make sure you remember to call your new function so it will run (since functions are only stored, but not run, when defined).</p><pre name="67ca" id="67ca" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">async function waiting() {<br>    const value = await num2();<br>    console.log(&#39;waiting&#39;, value);<br>}<br>waiting();</code></pre><p name="c7df" id="c7df" class="graf graf--p graf-after--pre">Run your program again and now you should see something like this:</p><pre name="d050" id="d050" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">waiting 2</code></pre><p name="de34" id="de34" class="graf graf--p graf-after--pre">Remember, <code class="markup--code markup--p-code">await</code> stops all flow until the promise returns. Of course, it is very quick in this example, since there&#39;s no delay caused by file reading or writing, web server calls, timeouts or anything else.</p><h3 name="d3aa" id="d3aa" class="graf graf--h3 graf-after--p">Phase 3: DIY¬†<code class="markup--code markup--h3-code">Promise</code></h3><p name="069c" id="069c" class="graf graf--p graf-after--h3">Now, it‚Äôs time to create your own, custom <code class="markup--code markup--p-code">Promise</code><br>so that you can have some delay before the promise is resolved. If you&#39;d like to use <code class="markup--code markup--p-code">await</code> again, then you will need to wrap your experiment in a function (and call it).</p><pre name="d641" id="d641" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">async function waitForMyPromise() {<br>    const promise = new Promise((resolve) =&gt; {<br>        setTimeout(() =&gt; {<br>            resolve(&#39;done!!!&#39;);<br>        }, 1000)<br>    });</code></pre><pre name="8aa4" id="8aa4" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">    const result = await promise;<br>    console.log(&#39;my promise is&#39;, result);<br>}<br>waitForMyPromise();</code></pre><p name="37d9" id="37d9" class="graf graf--p graf-after--pre">This time when you run your program, you will need to wait one second (1000 milliseconds) before the final message will appear.</p><pre name="1c8c" id="1c8c" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">my promise is done!!!</code></pre><h3 name="008d" id="008d" class="graf graf--h3 graf-after--pre">Phase 4: And <code class="markup--code markup--h3-code">then</code>¬†...</h3><p name="812e" id="812e" class="graf graf--p graf-after--h3">As an alternative, you could also use <code class="markup--code markup--p-code">then</code> to wait for a promise; even a custom one. For example, you can create another <code class="markup--code markup--p-code">new Promise</code> and attach¬†<code class="markup--code markup--p-code">.then()</code> to it.</p><pre name="85e3" id="85e3" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">new Promise((resolve) =&gt; {<br>    setTimeout(() =&gt; {<br>        resolve(&#39;done!&#39;);<br>    }, 1500)<br>}).then(r =&gt; console.log(&#39;then my other promise is&#39;, r));</code></pre><p name="8bf1" id="8bf1" class="graf graf--p graf-after--pre">Now, when running your program the output would look something like this.</p><pre name="4ba5" id="4ba5" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">my promise is done!!!<br>then my other promise is done!!!</code></pre><p name="cc7c" id="cc7c" class="graf graf--p graf-after--pre">Maybe your statements are in the other order, depending on the timing you set for each <code class="markup--code markup--p-code">setTimeout</code>¬†. Feel free to experiment with different values, if you&#39;d like before continuing.</p><h3 name="5de4" id="5de4" class="graf graf--h3 graf-after--p">Phase 5: About <code class="markup--code markup--h3-code">setTimeout</code></h3><p name="5fb2" id="5fb2" class="graf graf--p graf-after--h3">As you can see, <code class="markup--code markup--p-code">setTimeout</code> does not follow the Promises pattern. However, you could create your own <code class="markup--code markup--p-code">wait</code> function to remedy this. In the beginning of this project, you discovered that an <code class="markup--code markup--p-code">async</code><br>function returns a promise.</p><pre name="14db" id="14db" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">function wait(ms) {<br>  return new Promise(resolve =&gt; setTimeout(resolve, ms));<br>}</code></pre><p name="4e09" id="4e09" class="graf graf--p graf-after--pre">This benefit here is all waiting can use the same flow in your code regardless of whether it is a file read or write, web calls, or even timeout!¬†:)</p><p name="c39a" id="c39a" class="graf graf--p graf-after--p">Go ahead and try it out. See if you can cause a two-second pause before a message displays. Challenge yourself by writing the code before you scroll down to see an example.</p><p name="bcba" id="bcba" class="graf graf--p graf-after--p">‚Ä¶</p><p name="37fb" id="37fb" class="graf graf--p graf-after--p">‚Ä¶</p><p name="f203" id="f203" class="graf graf--p graf-after--p">‚Ä¶</p><pre name="29c2" id="29c2" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">async function doStuff() {<br>  await wait(2000)<br>  console.log(&#39;The waiting is over!&#39;)<br>}<br>doStuff();</code></pre><h3 name="5aaa" id="5aaa" class="graf graf--h3 graf-after--pre">Phase 6: <code class="markup--code markup--h3-code">reject</code>¬†...¬†<code class="markup--code markup--h3-code">catch</code></h3><p name="089b" id="089b" class="graf graf--p graf-after--h3">Next, you should explore the negative side of async calls and Promises for those times they are unable to do what they were asked to do. In other words, the Promise triggers <code class="markup--code markup--p-code">reject</code> instead of <code class="markup--code markup--p-code">resolve</code>¬†.</p><p name="a212" id="a212" class="graf graf--p graf-after--p">Start by creating yourself a function that returns a promise. Give it one argument that is a random value, and use that value to determine if the promise is successful (<code class="markup--code markup--p-code">resolve</code> ) or unsuccessful (<code class="markup--code markup--p-code">reject</code> ).</p><pre name="e835" id="e835" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">const tryRandomPromise = (random) =&gt; new Promise((resolve, reject) =&gt; {<br>    if (random &gt; 0.5) {<br>        resolve(&#39;success!!!&#39;);<br>    } else {<br>        reject(&#39;random error&#39;);<br>    }<br>});</code></pre><p name="87a8" id="87a8" class="graf graf--p graf-after--pre">In order to test this, you may want to use a loop (e.g. <code class="markup--code markup--p-code">for</code> loop) to call it several times, and hopefully see both success and failure. For your first experiment, use¬†<code class="markup--code markup--p-code">.then()</code> and¬†<code class="markup--code markup--p-code">.catch()</code> to handle the two cases.</p><p name="11fe" id="11fe" class="graf graf--p graf-after--p">For an added challenge, you can also use the <code class="markup--code markup--p-code">wait</code><br>promise you created above in a chain with the random promise.</p><pre name="a6fd" id="a6fd" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">for (let i=1; i&lt;10; i++) {<br>    const random = Math.random();<br>    wait(2000 + random*1000)<br>        .then(() =&gt; tryRandomPromise(random))<br>        .then(result =&gt; console.log(&#39;random try #&#39;, i, result))<br>        .catch(error =&gt; console.error(&#39;random try #&#39;, i, error));<br>}</code></pre><p name="9575" id="9575" class="graf graf--p graf-after--pre">In this example, the wait is a minimum of 2 seconds and a maximum of 3 seconds. That is because <code class="markup--code markup--p-code">Math.random()</code> returns a value between 0 and 1. This choice was made so the new messages will appear after the other experiments. Of course, you can adjust the timeouts anyway you&#39;d like!</p><p name="ee66" id="ee66" class="graf graf--p graf-after--p">Because the same random number is used with the wait and the random promise, the output shows all the errors before the successes (in random numeric order).</p><pre name="891e" id="891e" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">... (other output here) ...<br>random try # 3 random error<br>random try # 8 random error<br>random try # 5 random error<br>random try # 1 random error<br>random try # 9 random error<br>random try # 6 success!!!<br>random try # 7 success!!!<br>random try # 2 success!!!<br>random try # 4 success!!!</code></pre><h3 name="2842" id="2842" class="graf graf--h3 graf-after--pre">Phase 7: <code class="markup--code markup--h3-code">try</code>¬†... <code class="markup--code markup--h3-code">await</code>¬†...¬†<code class="markup--code markup--h3-code">catch</code></h3><figure name="3496" id="3496" class="graf graf--figure graf--iframe graf-after--h3"><script src="https://gist.github.com/bgoonz/9b1a82ba45e69af099ec197c7b171af7.js"></script></figure><p name="336e" id="336e" class="graf graf--p graf-after--figure">The <code class="markup--code markup--p-code">await</code> approach to promises also works. Most developers find it easier to read, so they will use it whenever possible (sometimes you just have to use¬†<code class="markup--code markup--p-code">.then()</code> and¬†<code class="markup--code markup--p-code">.catch()</code> ). It&#39;s really a personal or team choice most of the time. Since you are exploring Promises in this project, go ahead and create a second version of the functionality above using the <code class="markup--code markup--p-code">await</code> approach.</p><p name="21bc" id="21bc" class="graf graf--p graf-after--p">First, remember that calls to <code class="markup--code markup--p-code">await</code> must be within an <code class="markup--code markup--p-code">async</code> function. Second, realize that the <code class="markup--code markup--p-code">wait</code> promise you create only returns successfully and never returns a value, it is simple to call using <code class="markup--code markup--p-code">await wait(&lt;your timeout here&gt;)</code>¬†. Finally, when using <code class="markup--code markup--p-code">await</code> with a promise that calls <code class="markup--code markup--p-code">reject</code>¬†, that wrapping the call in a<code class="markup--code markup--p-code">try</code> block will trigger the <code class="markup--code markup--p-code">catch</code> block in the error case.</p><p name="49da" id="49da" class="graf graf--p graf-after--p">Here‚Äôs an example of a possible <code class="markup--code markup--p-code">async</code> function. You will probably write something similar.</p><pre name="d147" id="d147" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">const tryTryAgain = async (i) =&gt; {<br>    const random = Math.random();</code></pre><pre name="09be" id="09be" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">    // no need for try-catch if there&#39;s no possibility of error (rarely happens)<br>    await wait(3000 + random*1000);</code></pre><pre name="f5dc" id="f5dc" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">    // usually you need to wrap the await to gracefully handle the error<br>    try {<br>        const result = await tryRandomPromise(random);<br>        console.log(&#39;random again #&#39;, i, result);<br>    } catch (error) {<br>        console.error(&#39;random again #&#39;, i, error);<br>    }<br>};</code></pre><p name="be0f" id="be0f" class="graf graf--p graf-after--pre">Finally, you can call your function in a <code class="markup--code markup--p-code">for</code> loop again if you&#39;d like to see a variety of results.</p><pre name="1c17" id="1c17" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">for (let i=1; i&lt;10; i++) {<br>    tryTryAgain(i);<br>}</code></pre><p name="30c9" id="30c9" class="graf graf--p graf-after--pre">If all goes well, when you run your program, you‚Äôll have one more set of outputs for this part of the experiment.</p><pre name="5bc0" id="5bc0" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">random again # 7 random error<br>random again # 2 random error<br>random again # 1 success!!!<br>random again # 6 success!!!<br>random again # 5 success!!!<br>random again # 8 success!!!<br>random again # 4 success!!!<br>random again # 9 success!!!<br>random again # 3 success!!!</code></pre><h3 name="f267" id="f267" class="graf graf--h3 graf-after--pre">Phase 8: Appreciate asynchronous functions</h3><p name="1227" id="1227" class="graf graf--p graf-after--h3">In order to really appreciate the asynchronous nature of Promises, you may add one additional <code class="markup--code markup--p-code">console.log</code> to the end of your file.</p><pre name="ef7f" id="ef7f" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">console.log(&#39;END OF PROGRAM&#39;);</code></pre><p name="f5e6" id="f5e6" class="graf graf--p graf-after--pre">Before you run your program, you can challenge yourself to predict the order and timing of the log messages (try to predict when ‚ÄúEND OF PROGRAM‚Äù will be logged). Also, feel free to rerun your program as many times as you‚Äôd like until you feel like you fully understand why the order and timing happens as it does.</p><h3 name="08fc" id="08fc" class="graf graf--h3 graf-after--p">Solutions:</h3><pre name="96fe" id="96fe" class="graf graf--pre graf-after--h3">//! Phase 1:<br>//- create two similar functions.<br>//- Each can return a number or string. <br>//-Before the second function, place the async keyword. <br>//-Use the console to log the calls to both functions.</pre><pre name="2184" id="2184" class="graf graf--pre graf-after--pre">//function num1() {<br>//    return 1;<br>//}<br>//async function num2() {<br>//    return 2;<br>//}<br>//console.log( &#39;num1&#39;, num1() ); //num1 1<br>//console.log( &#39;num2&#39;, num2() ); //num2 Promise {2}</pre><pre name="40fe" id="40fe" class="graf graf--pre graf-after--pre">//-When you run your program (node promises.js ), you should see something like this:<br>/*<br> *   num1 1<br> *   num2 Promise {<br> *       2<br> *   }<br> */<br>//-Notice that the &quot;plain&quot; function just returns the value <br>//-the &quot;async&quot; function returns a promise. <br>//#Now add another call to the async function and attach the then function to get its result and log it.</pre><pre name="2534" id="2534" class="graf graf--pre graf-after--pre">//num2().then( (result) =&gt; console.log( result ) ); //2</pre><pre name="18c9" id="18c9" class="graf graf--pre graf-after--pre">//!Phase 2: await<br>//-Declare a constant that awaits the call to your other async function and logs the value. <br>//-remember to call your new function so it will run <br>//-(since functions are only stored, but not run, when defined).<br><br></pre><pre name="6bd0" id="6bd0" class="graf graf--pre graf-after--pre">//-Run your program again and now you should see something like this:<br>//*waiting 2</pre><pre name="6391" id="6391" class="graf graf--pre graf-after--pre">//-await stops all flow until the promise returns.</pre><pre name="f117" id="f117" class="graf graf--pre graf-after--pre">//!Phase 3: DIY Promise ( custom Promise so that you can have some delay before the promise is resolved. )<br>//#If you&#39;d like to use await again, then you will need to wrap your experiment in a function (and call it).<br><br></pre><pre name="a54f" id="a54f" class="graf graf--pre graf-after--pre">//---------------------------------------------------------------------------------------<br>////                  |<br>//// official answer  ÀÖ<br>/*<br>async function waitForMyPromise() {<br>    const promise = new Promise( ( resolve ) =&gt; {<br>        setTimeout( () =&gt; {<br>            resolve( &#39;done!!!&#39; );<br>        }, 1000 )<br>    } );<br>    const result = await promise;<br>    console.log( &#39;my promise is&#39;, result );<br>}<br>waitForMyPromise();<br>*/<br>//-This time when you run your program, you will need to wait one second (1000 milliseconds) before the final message will appear.<br>//*my promise is done!!!<br>//!Phase 4: And then ...<br>//- you could also use (then) to wait for a promise; even a custom one. <br>//- you can create another new Promise and attach .then() to it.</pre><pre name="0862" id="0862" class="graf graf--pre graf-after--pre">//new Promise( ( resolve ) =&gt; {<br>//    setTimeout( () =&gt; {<br>//        resolve( &#39;2&#39; );<br>//    }, 2000 )<br>//} ).then( ( resu ) =&gt; console.log( &#39;my promise:&#39;, resu, &#39;my other promise:&#39;, resu ) ); //my promise: 2 my other promise: 2<br><br></pre><pre name="fa37" id="fa37" class="graf graf--pre graf-after--pre">/*<br>new Promise( ( resolve ) =&gt; {<br>    setTimeout( () =&gt; {<br>        resolve( &#39;done!&#39; );<br>    }, 1500 )<br>} ).then( r =&gt; console.log( &#39;then my other promise is&#39;, r ) );<br>*/<br>//-Now, when running your program the output would look something like this.<br>//*my promise is done!!!<br>//*then my other promise is done!!!<br><br></pre><pre name="d0e7" id="d0e7" class="graf graf--pre graf-after--pre">//!Phase 5: About setTimeout:</pre><pre name="1dc2" id="1dc2" class="graf graf--pre graf-after--pre">//-setTimeout does not follow the Promises pattern.<br>//-you could create your own wait function to remedy this<br>//-you already discovered that an async function returns a promise.<br><br></pre><pre name="fdf8" id="fdf8" class="graf graf--pre graf-after--pre">function wait( ms ) {<br>    return new Promise( ( resolve ) =&gt; {<br>        setTimeout( resolve, ms ) //*resolve of new promise is similar to .then which calls setTimeout and passes resolve into the callback of the setTimeout function.<br>    } );<br>}<br>wait();</pre><pre name="5f92" id="5f92" class="graf graf--pre graf-after--pre">//-all waiting can use the same flow in your code regardless of whether it is a file read or write, web calls, or even timeout! üòÉ</pre><pre name="922d" id="922d" class="graf graf--pre graf-after--pre">//#Go ahead and try it out. See if you can cause a two-second pause before a message displays.<br>/*<br>async function doStuff() {<br>    await wait( 2000 )<br>    console.log( &#39;The waiting is over!&#39; )<br>}<br>doStuff();<br>*/</pre><pre name="847b" id="847b" class="graf graf--pre graf-after--pre">//!Phase 6: reject ... catch</pre><pre name="ce42" id="ce42" class="graf graf--pre graf-after--pre">//-explore the negative side of async calls and Promises for those times they are unable to do what they were asked to do. <br>//-In other words, the Promise triggers reject instead of resolve .<br><br></pre><pre name="dc5a" id="dc5a" class="graf graf--pre graf-after--pre">//#Start by creating yourself a function that returns a promise. <br>//#Give it one argument that is a random value,<br>//# and use that value to determine if the promise is successful (resolve ) or unsuccessful (reject ).</pre><pre name="04d4" id="04d4" class="graf graf--pre graf-after--pre">/*<br>const tryRandomPromise = ( random ) =&gt; new Promise( ( resolve, reject ) =&gt; {<br>    if ( random &gt; 0.5 ) {<br>        resolve( &#39;success!!!&#39; );<br>    } else {<br>        reject( &#39;random error&#39; );<br>    }<br>} );<br>*/<br><br></pre><pre name="cd89" id="cd89" class="graf graf--pre graf-after--pre">/*<br>n order to test this, you may want to use a loop( e.g.for loop ) to call it several times, and hopefully see both success and failure.For your first experiment, use.then() and.catch() to handle the two cases.<br>For an added challenge, you can also use the wait<br>promise you created above in a chain with the random promise.<br>for ( let i = 1; i &lt; 10; i++ ) {<br>    const random = Math.random();<br>    wait( 2000 + random * 1000 )<br>        .then( () =&gt; tryRandomPromise( random ) )<br>        .then( result =&gt; console.log( &#39;random try #&#39;, i, result ) )<br>        .catch( error =&gt; console.error( &#39;random try #&#39;, i, error ) );<br>}<br>In this example, the wait is a minimum of 2 seconds and a maximum of 3 seconds.That is because Math.random() returns a value between 0 and 1. This choice was made so the new messages will appear after the other experiments.Of course, you can adjust the timeouts anyway you &#39;d like!<br>Because the same random number is used with the wait and the random promise, the output shows all the errors before the successes( in random numeric order ).<br>*/</pre><figure name="c3c5" id="c3c5" class="graf graf--figure graf--iframe graf-after--pre"><script src="https://gist.github.com/bgoonz/7f395bbbfd76204954ea6e9a6cd0c090.js"></script></figure><p name="356f" id="356f" class="graf graf--p graf-after--figure graf--trailing"><em class="markup--em markup--p-em">More content at </em><a href="http://plainenglish.io/" data-href="http://plainenglish.io/" class="markup--anchor markup--p-anchor" rel="noopener noreferrer noopener" target="_blank"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">plainenglish.io</em></strong></a></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@bryanguner" class="p-author h-card">Bryan Guner</a> on <a href="https://medium.com/p/f5ebe3ead6ac"><time class="dt-published" datetime="2021-09-15T09:29:12.164Z">September 15, 2021</time></a>.</p><p><a href="https://medium.com/@bryanguner/exploring-promises-f5ebe3ead6ac" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 14, 2021.</p></footer></article></body></html>